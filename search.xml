<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Github Pages+HTML5 up制作个人主页及绑定二级域名</title>
      <link href="/2019/html_page/"/>
      <url>/2019/html_page/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Update on A.D.2019-09-23</p></blockquote><p>好看是第一生产力​qwq</p><a id="more"></a><blockquote><p><a href="http://chitanda.me/2015/11/03/multiple-git-pages-in-one-github-account/" target="_blank" rel="noopener">单个GitHub帐号下添加多个GitHub Pages的相关问题| 我很好奇</a></p></blockquote><p>首先我们要知道GitHub Pages可以有多个，项目名为<code>YourGitHubName.github.io</code>的Pages使用这个域名访问，新添加一个项目<code>ProjectName</code>并设置为Pages项目后，使用<code>YourGitHubName.github.io/ProjectName</code>进行访问，那么我们可以使用一个Pages托管Hexo博客，一个Pages托管个人主页.</p><p>这里介绍一个网站提供了很多个人主页的模板<br><a href="https://html5up.net" target="_blank" rel="noopener">https://html5up.net</a><br>我们选择并下载其中一个，直接修改即可，有一定HTML和CSS基础都可以很轻松的修改，你需要一个浏览器并会使用控制台以及抓取元素和一个编辑器例如vscode即可开始编写.</p><p>那么你还需要会使用git并把这个网站的源代码上传到GitHub的repo上，不会上网找个教程吧.</p><p>那然后就是域名绑定了，如果你用域名绑定过GitHub Pages的话，你就知道域名的DNS设置要设置几个A选项，这里不讲那是啥玩意了，总之这个选项是设置GitHub的ip地址的，有空我再找链接吧，自己去查GitHub的文档就行。然后你要设置一个CNAME，设置<code>YoutGitHubName.github.io</code>，然后在Github的repo里添加一个CNAME文件内容是你的域名全称并且不带https，www这样的前缀.</p><p>那么现在有两个页面，我们可以把主域名解析到个人主页上，使用blog二级域名解析到博客上，具体设置就是在域名DNS设置里设置二级域名并且同样解析到<code>YoutGitHubName.github.io</code>上，然后分别在个人主页的CNAME里设置<code>域名</code>和博客的CNAME里设置<code>blog.域名</code>，记得打开GitHub Pages绑定个人域名的https.</p><p>现在等一会DNS解析生效和GitHub的https证书申请完毕应该就没什么问题了.</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML </tag>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「莫比乌斯反演」</title>
      <link href="/2019/mobius/"/>
      <url>/2019/mobius/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Update on A.D.2019-09-23</p></blockquote><p>会有一天填坑的</p><a id="more"></a><blockquote><p>参考资料：<br><a href="https://www.luogu.org/blog/An-Amazing-Blog/mu-bi-wu-si-fan-yan-ji-ge-ji-miao-di-dong-xi" target="_blank" rel="noopener">莫比乌斯反演-让我们从基础开始</a><br><a href="http://www.cnblogs.com/peng-ym/p/8647856.html" target="_blank" rel="noopener">莫比乌斯反演_cnblogs_peng-ym</a><br><a href="https://www.luogu.org/problemnew/solution/P2257" target="_blank" rel="noopener">P2257 YY的GCD 题解</a><br><a href="https://www.cnblogs.com/candy99/p/6607559.html" target="_blank" rel="noopener">容斥原理 与 莫比乌斯反演</a><br><a href="http://www.cnblogs.com/peng-ym/p/8661118.html" target="_blank" rel="noopener">整除分块_peng-ym</a><br><a href="https://www.cnblogs.com/pks-t/p/9212764.html#_label4" target="_blank" rel="noopener">OI生涯中的各种数论算法的证明</a></p></blockquote><h1 id="整除分块"><a href="#整除分块" class="headerlink" title="整除分块"></a>整除分块</h1><h2 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h2><p>求：</p><script type="math/tex; mode=display">\sum_{i=1}^{n}\lfloor\frac{n}{i}\rfloor</script><p>对于每个$\lfloor\frac{n}{i}\rfloor$值相同的区间$[l,r]$有$r=n/(n/l)$，即对于$\forall x\in [i,n/(n/i)]$有$x=\lfloor\frac{n}{i}\rfloor$.</p><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>$O(\sqrt{n})$</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="lang-c++">for(int l = 1, r; l &lt;= n; l = r + 1){    r = n / (n / l);    ans += (r - l + 1) * (n / l);}</code></pre><h1 id="数论函数"><a href="#数论函数" class="headerlink" title="数论函数"></a>数论函数</h1><p>满足$f(ab)=f(a)f(b),gcd(a,b)=1$的数论函数称为积性函数<br>满足$f(ab)=f(a)f(b)$的数论函数称为完全积性函数</p><h2 id="积性函数"><a href="#积性函数" class="headerlink" title="积性函数"></a>积性函数</h2><p>$\varphi(n)$：欧拉函数，表示小于n的正整数中与n互质的数的数目</p><script type="math/tex; mode=display">\varphi(x)=x\prod_{i=1}^{n}\left(1-\frac{1}{p_i}\right)</script><p>$\mu(n)$：莫比乌斯函数<br>$\sigma(n)$：因子和函数，表示n的正因子和<br>$d(n)​$：因子个数函数，表示n的正因数个数</p><h2 id="完全积性函数"><a href="#完全积性函数" class="headerlink" title="完全积性函数"></a>完全积性函数</h2><p>$\epsilon(n)=[n=1]$：单位函数<br>$id(n)=n$：恒等函数<br>$1(n)=1$：常函数</p><h1 id="狄利克雷卷积"><a href="#狄利克雷卷积" class="headerlink" title="狄利克雷卷积"></a>狄利克雷卷积</h1><p>对于数论函数$f(n),g(n)$定义<code>Dirichlet卷积</code>为</p><script type="math/tex; mode=display">(f\times g)(n)=\sum_{d\mid n}f(d)g(\frac{n}{d})</script><p>若$f,g$为积性函数，$f*g,f\times g$为积性函数</p><h2 id="常用的狄利克雷卷积"><a href="#常用的狄利克雷卷积" class="headerlink" title="常用的狄利克雷卷积"></a>常用的狄利克雷卷积</h2><script type="math/tex; mode=display">id=\varphi\times 1\quad n=\sum_{d\mid n}\varphi(d)</script><script type="math/tex; mode=display">\epsilon = \mu \times 1 \quad \epsilon(n) = \sum_{d\mid n}\mu(d)</script><script type="math/tex; mode=display">\varphi = \mu \times id \quad \varphi(n)=\sum_{d\mid n}d\mu(\frac{n}{d})=\sum_{d\mid n}\mu(d)\frac{n}{d}</script><h1 id="莫比乌斯函数"><a href="#莫比乌斯函数" class="headerlink" title="莫比乌斯函数"></a>莫比乌斯函数</h1><script type="math/tex; mode=display">\mu(d) = \left\{\begin{matrix}1,d=1\\ (-1)^n,d=\prod_{i=1}^{n}p_i^{k_i} , \forall p_i, k_i=1\\ 0,d=\prod_{i=1}^{n}p_i^{k_i} , \exists p_i, k_i\geqslant 2\end{matrix}\right.</script><h2 id="线性筛求莫比乌斯函数"><a href="#线性筛求莫比乌斯函数" class="headerlink" title="线性筛求莫比乌斯函数"></a>线性筛求莫比乌斯函数</h2><pre><code class="lang-c++">void sieve(){    mu[1] = 1;    for(int i = 2; i &lt;= N; i++) {        if(!vis[i]) prime[++cnt] = i, mu[i] = -1;        for(int j = 1; j &lt;= cnt &amp;&amp; i * prime[j] &lt;= N; j++) {            vis[i * prime[j]] = 1;            if(i % prime[j] == 0) break;            mu[i * prime[j]] = -mu[i];        }    }}</code></pre><h2 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h2><p>由<br>$<br>\mu \times 1 = \epsilon<br>$<br>得</p><script type="math/tex; mode=display">\sum_{d|n}\mu(d)=[n=1]</script><h2 id="莫比乌斯反演"><a href="#莫比乌斯反演" class="headerlink" title="莫比乌斯反演"></a>莫比乌斯反演</h2><p>对于函数</p><script type="math/tex; mode=display">f=g\times 1</script><p>有</p><script type="math/tex; mode=display">g=\mu \times f</script><p>即对于</p><script type="math/tex; mode=display">f(n)=\sum_{d\mid n}g(d)</script><p>有</p><script type="math/tex; mode=display">g(n)=\sum_{d\mid n}\mu(d)f(\frac{n}{d})</script><h1 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h1><h2 id="P2303-SDOI2012-Longge的问题"><a href="#P2303-SDOI2012-Longge的问题" class="headerlink" title="P2303 [SDOI2012]Longge的问题"></a><a href="https://www.luogu.org/problemnew/show/P2303" target="_blank" rel="noopener">P2303 [SDOI2012]Longge的问题</a></h2><script type="math/tex; mode=display">\sum_{i=1}^{n}gcd(i,n)\\=\sum_{d\mid n}d\times\sum_{i=1}^{n}[gcd(i,n)=d]\\=\sum_{d \mid n}d \times \sum_{i=1}^{\frac{n}{d}}[gcd\left ( i,\frac{n}{d}\right)=1]\\=\sum_{d \mid n} d \cdot \varphi\left ( \frac{n}{d} \right )</script><h2 id="P2257-YY的GCD"><a href="#P2257-YY的GCD" class="headerlink" title="P2257 YY的GCD"></a><a href="https://www.luogu.org/problemnew/show/P2257" target="_blank" rel="noopener">P2257 YY的GCD</a></h2><p>原式</p><script type="math/tex; mode=display">=\sum_{k=1}^{min(n,m)}\sum_{i=1}^{n}\sum_{j=1}^{m}[gcd(i,j)=k](k\in prime)</script><p>由</p><script type="math/tex; mode=display">\sum_{d|n}\mu(d)=[n=1]</script><p>得</p><script type="math/tex; mode=display">\sum_{d|gcd(i,j)}\mu(d)=[gcd(i,j)=1]</script><p>原式</p><script type="math/tex; mode=display">=\sum_{k=1}^{min(n,m)}\sum_{i=1}^{\lfloor{\frac{n}{k}}\rfloor}\sum_{j=1}^{\lfloor{\frac{m}{k}}\rfloor}\sum_{d|gcd(i,j)}\mu(d)(k\in prime)</script><script type="math/tex; mode=display">=\sum_{k=1}^{min(n,m)}\sum_{d=1}^{\lfloor{\frac{n}{k}}\rfloor}\mu(d){\lfloor{\frac{n}{kd}}\rfloor}{\lfloor{\frac{m}{kd}}\rfloor})(k\in prime)</script><p>设$T=kd$有原式</p><script type="math/tex; mode=display">=\sum_{k=1}^{min(n,m)}\sum_{d=1}^{\lfloor{\frac{n}{k}}\rfloor}\mu(d){\lfloor{\frac{n}{T}}\rfloor}{\lfloor{\frac{m}{T}}\rfloor}(k\in prime)</script><script type="math/tex; mode=display">=\sum_{T=1}^{min(n,m)}{\lfloor{\frac{n}{T}}\rfloor}{\lfloor{\frac{m}{T}}\rfloor}\sum_{k|T,k\in prime}\mu(\frac{T}{k})</script><pre><code class="lang-c++">#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;const int _ = 10000005, N = 10000000;int T, n, m, cnt;int vis[_], prime[_], mu[_], f[_], sum[_];void sieve(){    mu[1] = 1;    for(int i = 2; i &lt;= N; i++) {        if(!vis[i]) prime[++cnt] = i, mu[i] = -1;        for(int j = 1; j &lt;= cnt &amp;&amp; i * prime[j] &lt;= N; j++) {            vis[i * prime[j]] = 1;            if(i % prime[j] == 0) break;            mu[i * prime[j]] = -mu[i];        }    }    for(int i = 1; i &lt;= cnt; i++)        for(int j = 1; prime[i] * j &lt;= N; j++)            f[j * prime[i]] += mu[j];    for(int i = 1; i &lt;= N; i++)        sum[i] = sum[i - 1] + f[i];}int main(){    sieve();    scanf(&quot;%d&quot;, &amp;T);    while(T--) {        scanf(&quot;%d%d&quot;, &amp;n, &amp;m);        if(n &gt; m) swap(n, m);        long long ans = 0;        for(int l = 1, r = 0; l &lt;= n; l = r + 1) {            r = min(n / (n / l), m / (m / l));            ans += 1LL * (n / l) * (m / l) * (sum[r] - sum[l - 1]);        }        printf(&quot;%lld\n&quot;, ans);    }    return 0;}</code></pre><h2 id="P3455-POI2007-ZAP-Queries"><a href="#P3455-POI2007-ZAP-Queries" class="headerlink" title="P3455 [POI2007]ZAP-Queries"></a><a href="https://www.luogu.org/problemnew/show/P3455" target="_blank" rel="noopener">P3455 [POI2007]ZAP-Queries</a></h2><script type="math/tex; mode=display">\sum_{i=1}^n\sum_{j=1}^m[gcd(i,j)=k]</script><script type="math/tex; mode=display">=\sum_{i=1}^{\lfloor{\frac{n}{k}}\rfloor}\sum_{j=1}^{\lfloor{\frac{m}{k}}\rfloor}[gcd(i,j)=1]</script><script type="math/tex; mode=display">=\sum_{i=1}^{\lfloor{\frac{n}{k}}\rfloor}\sum_{j=1}^{\lfloor{\frac{m}{k}}\rfloor}\sum_{d\mid gcd(i,j)} \mu(d)</script><script type="math/tex; mode=display">=\sum_{d=1}^{min(n,m)}\mu(d)\lfloor{\frac{n}{d}}\rfloor\lfloor{\frac{m}{d}}\rfloor</script><pre><code class="lang-c++">#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;const int _ = 50005, N = 50000;int T, n, m, d;int vis[_], prime[_], mu[_], sum[_], cnt;void sieve(){    mu[1] = 1;    for(int i = 2; i &lt;= N; i++) {        if(!vis[i]) prime[++cnt] = i, mu[i] = -1;        for(int j = 1; j &lt;= cnt &amp;&amp; i * prime[j] &lt;= N; j++) {            vis[i * prime[j]] = 1;            if(i % prime[j] == 0) break;            mu[i * prime[j]] = -mu[i];        }    }    for(int i = 1; i &lt;= N; i++) sum[i] = sum[i - 1] + mu[i];}int main(){    sieve();    scanf(&quot;%d&quot;, &amp;T);    while(T--)    {        scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;d);        if(n &gt; m) swap(n, m);        n /= d; m /= d;        long long ans = 0;        for(int l = 1, r = 0; l &lt;= n; l = r + 1) {            r = min(n / (n / l), m / (m / l));            ans += 1LL * (n / l) * (m / l) * (sum[r] - sum[l - 1]);        }        printf(&quot;%lld\n&quot;, ans);    }    return 0;}</code></pre><h2 id="P2522-HAOI2011-Problem-b"><a href="#P2522-HAOI2011-Problem-b" class="headerlink" title="P2522 [HAOI2011]Problem b"></a><a href="https://www.luogu.org/problemnew/show/P2522" target="_blank" rel="noopener">P2522 [HAOI2011]Problem b</a></h2><script type="math/tex; mode=display">\sum_{i=a}^b\sum_{j=c}^d[gcd(i,j)=k]</script><script type="math/tex; mode=display">=\sum_{i=1}^b\sum_{j=1}^d[gcd(i,j)=k]-\sum_{i=1}^{a-1}\sum_{j=1}^d[gcd(i,j)=k]-\sum_{i=1}^b\sum_{j=1}^{c-1}[gcd(i,j)=k]+\sum_{i=1}^{a-1}\sum_{j=1}^{c-1}[gcd(i,j)=k]</script><script type="math/tex; mode=display">\sum_{i=1}^n\sum_{j=1}^m[gcd(i,j)=k]</script><script type="math/tex; mode=display">=\sum_{i=1}^{\lfloor{\frac{n}{k}}\rfloor}\sum_{j=1}^{\lfloor{\frac{m}{k}}\rfloor}[gcd(i,j)=1]</script><script type="math/tex; mode=display">=\sum_{i=1}^{\lfloor{\frac{n}{k}}\rfloor}\sum_{j=1}^{\lfloor{\frac{m}{k}}\rfloor}\sum_{d\mid gcd(i,j)} \mu(d)</script><script type="math/tex; mode=display">=\sum_{d=1}^{min(n,m)}\mu(d)\lfloor{\frac{n}{d}}\rfloor\lfloor{\frac{m}{d}}\rfloor</script><pre><code class="lang-c++">#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;const int _ = 50005, N = 50000;int T, a, b, c, d, k;int vis[_], prime[_], mu[_], sum[_], cnt;void sieve(){    mu[1] = 1;    for(int i = 2; i &lt;= N; i++) {        if(!vis[i]) prime[++cnt] = i, mu[i] = -1;        for(int j = 1; j &lt;= cnt &amp;&amp; i * prime[j] &lt;= N; j++) {            vis[i * prime[j]] = 1;            if(i % prime[j] == 0) break;            mu[i * prime[j]] = -mu[i];        }    }    for(int i = 1; i &lt;= N; i++) sum[i] = sum[i - 1] + mu[i];}long long calc(int n, int m, int k){    long long ans = 0;    n = n / k; m = m / k;    for(int l = 1, r = 0; l &lt;= min(n, m); l = r + 1) {        r = min(n / (n / l), m / (m / l));        ans += 1LL * (n / l) * (m / l) * (sum[r] - sum[l - 1]);    }    return ans;}int main(){    sieve();    scanf(&quot;%d&quot;, &amp;T);    while(T--)    {        scanf(&quot;%d%d%d%d%d&quot;, &amp;a, &amp;b, &amp;c, &amp;d, &amp;k);        long long ans = calc(b, d, k) - calc(a - 1, d, k) - calc(b, c - 1, k) + calc(a - 1, c - 1, k);        printf(&quot;%lld\n&quot;, ans);    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 莫比乌斯反演 </tag>
            
            <tag> 整除分块 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「后缀数组」</title>
      <link href="/2019/SA/"/>
      <url>/2019/SA/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Update on A.D.2019-09-23</p></blockquote><p>会有那么一天去做题的</p><a id="more"></a><blockquote><p>参考资料：<br>1.<a href="https://www.cnblogs.com/zwfymqz/p/8413523.html" target="_blank" rel="noopener">后缀数组详解</a><br>2.<a href="https://www.luogu.org/blog/i207M/hou-zhui-shuo-zu-xue-xi-bi-ji" target="_blank" rel="noopener">后缀数组-学习笔记</a><br>3.<a href="https://wenku.baidu.com/view/ed1be61e10a6f524ccbf85fd.html" target="_blank" rel="noopener">后缀数组——处理字符串的有力工具</a></p></blockquote><h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>$SA$排名为$i$的后缀的位置<br>$rk$位置为$i$的后缀的排名<br>$tp$第二关键字的排名为$i$的后缀的位置，还被用作$rank$的暂存<br>$tax$每个排名对应的后缀数量<br>后缀数组就是为了求出$sa$和$rk$</p><h1 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h1><p>$rk[sa[i]]=i$ $sa[rk[i]]=i$</p><p>$LCP(x,y) $：字符串x与字符串y的最长公共前缀，在这里<strong>指x号后缀与与y号后缀的最长公共前缀</strong></p><p>$height[i]=lcp ( sa[i],sa[i - 1] )$，即<strong>排名</strong>为$i$的后缀与<strong>排名</strong>为$i−1$的后缀的最长公共前缀</p><p>$H[i]：height[rak[i]]$，即$i$号后缀与它前一名的后缀的最长公共前缀</p><p>$H[i] \geqslant H[i - 1] - 1$ <strong>证明</strong> </p><p>$LCP(i,j)=LCP(j,i) $</p><p>$LCP(i,i)=len(sa[i])=n-sa[i]+1$</p><p>$LCP(i,k)=min\left\{height[j] \right\}(i+1&lt;=j&lt;=k)$</p><p>$S$不同的子串个数$\dfrac{n(n+1)}{2} -\sum_{i=1}^nheight[i]$</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><pre><code class="lang-c++">#include &lt;iostream&gt; #include &lt;cstdio&gt;#include &lt;string&gt;#define R register intusing namespace std;const int N = 1000005;string s;/* sa[i]：排名为i的后缀的位置rak[i]：从第i个位置开始的后缀的排名，下文为了叙述方便，把从第i个位置开始的后缀简称为后缀itp[i]：基数排序的第二关键字，意义与sa一样，即第二关键字排名为i的后缀的位置tax[i]：i号元素出现了多少次。辅助基数排序s：字符串，s[i]表示字符串中第i个字符串*/int n, m, sa[N], rk[N], tp[N], c[N];void _sort() {    for(R i = 1; i &lt;= m; ++i) c[i] = 0;    for(R i = 1; i &lt;= n; ++i) c[rk[i]]++;    for(R i = 1; i &lt;= m; ++i) c[i] += c[i - 1];    for(R i = n; i &gt;= 1; --i) sa[c[rk[tp[i]]]--] = tp[i];}void SA() {    m = 150;    for(R i = 1; i &lt;= n; ++i) rk[i] = s[i - 1], tp[i] = i;    _sort();    for(R w = 1, p = 0; p &lt; n &amp;&amp; w &lt;= n; m = p, w &lt;&lt;= 1) {        p = 0;        for(R i = 1; i &lt;= w; ++i) tp[++p] = n - w + i;        for(R i = 1; i &lt;= n; ++i) if(sa[i] &gt; w) tp[++p] = sa[i] - w;        _sort();        swap(tp, rk);        rk[sa[1]] = p = 1;        for(R i = 2; i &lt;= n; ++i)            rk[sa[i]] = (tp[sa[i - 1]] == tp[sa[i]] &amp;&amp; tp[sa[i - 1] + w] == tp[sa[i] + w])            ? p : ++p;    }}/*i号后缀：从i开始的后缀lcp(x,y)：字符串x与字符串y的最长公共前缀，在这里指x号后缀与与y号后缀的最长公共前缀height[i]：lcp(sa[i],sa[i-1])，即排名为i的后缀与排名为i-1的后缀的最长公共前缀H[i]：height[rak[i]]，即i号后缀与它前一名的后缀的最长公共前缀*/int Height[N];void Get() {    int j, k = 0;    for(int i = 1; i &lt;= n; i++) {        if(k) k--;        j = sa[rk[i] - 1];        while(s[i + k - 1] == s[j + k - 1]) ++k;        Height[rk[i]] = k;    }}int main(){    cin &gt;&gt; s;    n = s.length();    SA();    for(R i = 1; i &lt;= n; ++i) printf(&quot;%d &quot;, sa[i]);    cout &lt;&lt; endl;    Get();    return 0;}</code></pre><h1 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h1><p><a href="https://www.luogu.org/problemnew/show/P2408" target="_blank" rel="noopener">P2408 不同子串个数</a></p><p>$ans=\dfrac{n(n+1)}{2} -\sum height[i]$</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后缀数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「概率期望」</title>
      <link href="/2019/probability/"/>
      <url>/2019/probability/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Update on A.D.2019-09-23</p></blockquote><a id="more"></a><blockquote><p>参考资料：<a href="https://blog.csdn.net/qq_31073871/article/details/81077386" target="_blank" rel="noopener">条件概率/全概率/贝叶斯公式_CSDN</a><br><a href="https://baike.baidu.com/item/%E6%9D%A1%E4%BB%B6%E6%A6%82%E7%8E%87#1" target="_blank" rel="noopener">条件概率_百度百科</a></p></blockquote><h1 id="概率公式"><a href="#概率公式" class="headerlink" title="概率公式"></a>概率公式</h1><h2 id="条件概率公式"><a href="#条件概率公式" class="headerlink" title="条件概率公式"></a>条件概率公式</h2><p>设$A,B$是两个事件，且$P(B)&gt;0$,则在事件$B$发生的条件下，事件$A$发生的条件概率为$P(A|B)=\dfrac{P(AB)}{P(B)}$</p><h2 id="乘法公式"><a href="#乘法公式" class="headerlink" title="乘法公式"></a>乘法公式</h2><p>1.由条件概率公式得$P(AB)=P(A|B)P(B)=P(B|A)P(A)$<br>2.推广：对$\forall n \geq 2$当$P(A_1A_2…A_{n-1})&gt;0$时<br>有 $P(A_1A_2…A_{n-1}A{n})=P(A_1)P(A_2|A_1)P(A_3|A_1A_2)…P(A_n|A_1A_2…A_{n-1})$</p><h2 id="全概率公式"><a href="#全概率公式" class="headerlink" title="全概率公式"></a>全概率公式</h2><p>如果事件组$B_1,B_2,…,B_n$满足<br>1.$\forall i\neq j\in \left \{1,2,\cdots ,n  \right \},B_i\cap B_j = \varnothing$<br>2.$B_1\cup B_2\cup …\cup B_n=\Omega$<br>则称事件组$B_1,B_2,…,B_n$是样本空间$\Omega$的一个划分,或称为样本空间$\Omega$的一个完备事件组。<br>设事件组$\left \{B_i \right \}$是样本空间$\Omega$的一个划分，且$P(B_i)&gt;0(i \in \left \{1,2,\cdots ,n  \right \})$<br>对任一事件$A$，有$P(A)=\sum_{i=1}^{n}P(B_i)P(A|B_i)$</p><h2 id="贝叶斯公式"><a href="#贝叶斯公式" class="headerlink" title="贝叶斯公式"></a>贝叶斯公式</h2><p>设事件组$\left \{B_i \right \}$是样本空间$\Omega$的一个划分，则对任一事件$A(P(A)&gt;0)$,有<br>$P(B_i|A)=\dfrac{P(AB_i)}{P(A)}=\dfrac{P(B_i)P(A|B_i)}{\sum_{j=1}^{n}P(B_j)P(A|B_j)}$<br>上式即为贝叶斯公式，$B_i$常被视为导致试验结果$A$发生的”原因“，$P(B_i)(i\in \left \{1,2,\cdots ,n  \right \})$表示各种原因发生的可能性大小，故称先验概率；$P(B_i|A)(i\in \left \{1,2,\cdots ,n  \right \})$则反映当试验产生了结果$A$之后，再对各种原因概率的新认识，故称后验概率。</p><h1 id="数学期望"><a href="#数学期望" class="headerlink" title="数学期望"></a>数学期望</h1><p>离散型随机变量$X$的取值为$x_1,x_2,x_3,…,x_{n}$，$p_1,p_2,p_3,…,p_{n}$为$X$对应取值的概率<br>则称$E(X)=\sum_{i=1}^{n}p_{i}x_{i}$为离散型随机变量$X$的<strong>数学期望</strong><br>性质：$E(aX+bY)=aE(X)+bE(Y)$</p><h1 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h1><p><a href="https://www.luogu.org/problemnew/show/P4316" target="_blank" rel="noopener">P4316 绿豆蛙的归宿</a><br>设$F[x]$表示从$x$走到$N$期望长度<br>$F[x]=\frac{1}{k}\sum_{i=1}^{k}(F[y_{i}]+z_{i})$<br>$F[N]=0$<br>$Ans=F[1]$<br><a href="https://www.luogu.org/problemnew/show/P1365" target="_blank" rel="noopener">P1365 WJMZBMR打osu! / Easy</a><br>设$f[x]$表示到$x$期望得分  $g[x]$表示以$x$结尾期望$o$序列长度<br>$s[i]==x f[i]=f[i-1],g[i]=0$<br>$s[i]==o f[i]=f[i-1]+2*g[i-1]+1,g[i]=g[i-1]+1$<br>$s[i]==? f[i]=f[i-1]+\frac{(2g[i-1]+1)+0}{2},g[i]=\frac{(g[i-1]+1)+0}{2}$<br>$Ans=f[n]$<br><a href="https://www.luogu.org/problemnew/show/P1654" target="_blank" rel="noopener">P1654 OSU!</a><br>$p[i]$表示$i$位置成功概率<br>设$f[i]$表示到$i$期望得分 $x1[i]$以$i$结尾$1$序列期望长度 $x2[i]$表示以$i$结尾$1$序列期望长度平方<br>$(x+1)^{3}=(x^{2}+2x+1)(x+1)=x^{3}+3x^{2}+3x+1$<br>若第$i$次成功且有$f[i-1]=x^{3}则f[i]=f[i-1]+3x^{2}+3x+1$<br>$x1[i]=(x1[i-1]+1)p[i]$<br>$x2[i]=(x2[i-1]+2x1[i-1]+1)p[i]$<br>$f[i]=f[i-1]+(3x2[i-1]+3x1[i-1]+1)p[i]$<br>$Ans=f[n]$<br><a href="https://www.luogu.org/problemnew/show/P1297" target="_blank" rel="noopener">P1297 [国家集训队]单选错位</a><br>$Ans=\sum_{i=1}^{n-1}\frac{1}{max(a_i,a_{i+1})}+\frac{1}{max(a_1,a_n)}​$</p>]]></content>
      
      
      
        <tags>
            
            <tag> 概率 </tag>
            
            <tag> 期望 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++STL的OI常用内容</title>
      <link href="/2019/C++_stl/"/>
      <url>/2019/C++_stl/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Update on A.D.2019-09-23</p></blockquote><a id="more"></a><blockquote><p>参考资料:<br><a href="https://oi.men.ci/stl-in-oi/" target="_blank" rel="noopener">STL 在 OI 中的应用</a><br><a href="https://www.cnblogs.com/ChinaHook/p/6985444.html" target="_blank" rel="noopener">[C++ STL]Set和Multiset</a></p></blockquote><h1 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h1><h2 id="stack-后入先出（LIFO）栈"><a href="#stack-后入先出（LIFO）栈" class="headerlink" title="stack 后入先出（LIFO）栈"></a>stack 后入先出（LIFO）栈</h2><h3 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h3><pre><code class="lang-c++">#include&lt;stack&gt;</code></pre><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><pre><code class="lang-c++">stack&lt;int&gt; s;</code></pre><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><div class="table-container"><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td>q.top()</td><td>获取栈顶元素（并不删除）</td></tr><tr><td>q.pop()</td><td>删除栈顶元素</td></tr><tr><td>q.push(x)</td><td>向栈中加入元素</td></tr><tr><td>q.empty()</td><td>判断栈是否为空</td></tr></tbody></table></div><h1 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h1><h2 id="queue-先入先出（FIFO）队列"><a href="#queue-先入先出（FIFO）队列" class="headerlink" title="queue 先入先出（FIFO）队列"></a>queue 先入先出（FIFO）队列</h2><h3 id="头文件-1"><a href="#头文件-1" class="headerlink" title="头文件"></a>头文件</h3><pre><code class="lang-c++">#include&lt;queue&gt;</code></pre><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><pre><code class="lang-c++">queue&lt;int&gt; q;</code></pre><h3 id="函数-1"><a href="#函数-1" class="headerlink" title="函数"></a>函数</h3><div class="table-container"><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td>q.front()</td><td>获取队首元素（并不删除）</td></tr><tr><td>q.pop()</td><td>删除队首元素</td></tr><tr><td>q.push(x)</td><td>向队列中加入元素</td></tr><tr><td>q.empty()</td><td>判断队列是否为空</td></tr></tbody></table></div><h2 id="priority-queue-优先队列"><a href="#priority-queue-优先队列" class="headerlink" title="priority_queue 优先队列"></a>priority_queue 优先队列</h2><h3 id="头文件-2"><a href="#头文件-2" class="headerlink" title="头文件"></a>头文件</h3><pre><code class="lang-c++">#include&lt;queue&gt;</code></pre><h3 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h3><pre><code class="lang-c++">priority_queue&lt;int&gt; q; // 队头最大</code></pre><pre><code class="lang-c++">priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt; q; 队头最小</code></pre><h3 id="函数-2"><a href="#函数-2" class="headerlink" title="函数"></a>函数</h3><div class="table-container"><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td>q.top()</td><td>获取优先队列中最大的元素（并不删除），其时间复杂度为$O(1)$</td></tr><tr><td>q.pop()</td><td>删除优先队列中最大元素，其时间复杂度为$O(log n)$</td></tr><tr><td>q.push(x)</td><td>向优先队列中加入元素，其时间复杂度为$O(log n)$</td></tr><tr><td>q.empty()</td><td>判断优先队列是否为空</td></tr></tbody></table></div><h1 id="Set-与-Multiset"><a href="#Set-与-Multiset" class="headerlink" title="Set 与 Multiset"></a>Set 与 Multiset</h1><blockquote><p>set不允许重复 multiset允许重复</p><pre><code>例: set : 1 2 3 4 5 6multiset : 1 2 2 3 3 3</code></pre></blockquote><h2 id="头文件-3"><a href="#头文件-3" class="headerlink" title="头文件"></a>头文件</h2><pre><code class="lang-c++">#include &lt;set&gt;</code></pre><h2 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h2><pre><code class="lang-c++">multiset&lt;int&gt; s[N];//定义multiset&lt;int&gt;::iterator it;//迭代器</code></pre><h2 id="函数-3"><a href="#函数-3" class="headerlink" title="函数"></a>函数</h2><div class="table-container"><table><thead><tr><th>操作</th><th>效果</th></tr></thead><tbody><tr><td>s.size()</td><td>返回当前的元素数量</td></tr><tr><td>s.empty ()</td><td>判断大小是否为零，等同于$0==size()$，效率更高</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th>操作</th><th>效果</th></tr></thead><tbody><tr><td>count (elem)</td><td>返回元素值为$elem$的个数</td></tr><tr><td>find(elem)</td><td>返回元素值为$elem$的第一个元素，如果没有返回$end()$</td></tr><tr><td>lower _bound(elem)</td><td>返回元素值$&gt;=elem$的第一个元素位置</td></tr><tr><td>upper _bound (elem)</td><td>返回元素值$&gt;elem$的第一个元素位置</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th>操作</th><th>效果</th></tr></thead><tbody><tr><td>s.begin()</td><td>返回一个随机存取迭代器，指向第一个元素</td></tr><tr><td>s.end()</td><td>返回一个随机存取迭代器，指向最后一个元素的下一个位置</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th>操作</th><th>效果</th></tr></thead><tbody><tr><td>s.insert(elem)</td><td>插入一个$elem$副本，返回新元素位置，无论插入成功与否。</td></tr><tr><td>s.erase(elem)</td><td>删除与$elem$相等的所有元素，返回被移除的元素个数。</td></tr><tr><td>s.erase(pos)</td><td>移除迭代器$pos$所指位置元素，无返回值。</td></tr><tr><td>s.clear()</td><td>移除所有元素，将容器清空</td></tr></tbody></table></div><h1 id="离散化"><a href="#离散化" class="headerlink" title="离散化"></a>离散化</h1><h2 id="std-unique"><a href="#std-unique" class="headerlink" title="std::unique"></a>std::unique</h2><p>功能：对有序的容器重新排列，将第一次出现的元素从前往后排，其他重复出现的元素依次排在后面<br>返回值：返回迭代器，迭代器指向的是重复元素的首地址</p><h2 id="std-lower-bound"><a href="#std-lower-bound" class="headerlink" title="std::lower_bound"></a>std::lower_bound</h2><p>lower_bound()返回一个 iterator 它指向在[first,last)标记的有序序列中可以插入value，而不会破坏容器顺序的第一个位置，而这个位置标记了第一个大于等于value 的值。<br>ForwardIter lower_bound(ForwardIter first, ForwardIter last,const _Tp&amp; val)算法返回一个非递减序列[first, last)中的第一个大于等于值val的位置。</p><h2 id="std-upper-bound"><a href="#std-upper-bound" class="headerlink" title="std::upper_bound"></a>std::upper_bound</h2><p>upper_bound()返回一个 iterator 它指向在[first,last)标记的有序序列中可以插入value，而不会破坏容器顺序的第一个位置，而这个位置标记了第一个大于value 的值。这两个函数为C++ STL内的函数。<br>ForwardIter upper_bound(ForwardIter first, ForwardIter last, const _Tp&amp; val)算法返回一个非递减序列[first, last)中第一个大于val的位置。</p><pre><code class="lang-c++">std::sort(b + 1, b + cnt + 1);int *end = std::unique(b + 1, b + cnt + 1);for(int i = 1; i &lt;= n; i++)a[i] = lower_bound(b + 1, end, a[i]) - b;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> stl_queue </tag>
            
            <tag> stl_set </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「分层图」</title>
      <link href="/2019/layered_graph/"/>
      <url>/2019/layered_graph/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Update on A.D.2019-09-23</p></blockquote><a id="more"></a><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>在一个无向图$G=(V,E)$中，可以改变$k$条边的权值为$\Delta w$，求单源最短路径。</p><h1 id="分层图"><a href="#分层图" class="headerlink" title="分层图"></a>分层图</h1><p>分层图的想法就是如果有$k$条边权值变为$\Delta w$，就建$k+1$层图。</p><p><img src="https://img2018.cnblogs.com/blog/1563249/201812/1563249-20181230113914333-520736294.png" alt></p><p>这个图实际上是这样的，对于每$1$层中相连的点对$(u,v)$连权值为$w$的无向边，对于每个在原图中相连的点对$(u,v)$由$k$层点$u_k$向$k+1$层点$v_{k+1}$以及$k$层点$v_k$向$k+1$层点$u_{k+1}$连权值为$\Delta w$的有向边，方向是从$k$层向$k+1$层。<br>这样构造完成一张分层图后，从第$1$层的起始点$s_1$求单源最短路径，最终第$k + 1$层的终点$t_{k+1}$的单源最短路径值即为答案所求。<br>原理其实很简单，如果从$k$层图到$k+1$层图，有向边$(u_k,v_{k+1})$是一条$\Delta w$权边，走这条边，相当于把$w$权边变成了$\Delta w$权边，并且进入了$k+1$层。这样如果有$k+1$层图的话，相当于进行了$k$次这种操作，自然就在$k+1$层图求最短路中实现了$k$次改变边权的目标。</p><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="P2939-USACO09FEB-改造路Revamping-Trails"><a href="#P2939-USACO09FEB-改造路Revamping-Trails" class="headerlink" title="P2939 [USACO09FEB]改造路Revamping Trails"></a><a href="https://www.luogu.org/problemnew/show/P2939" target="_blank" rel="noopener">P2939 [USACO09FEB]改造路Revamping Trails</a></h2><pre><code class="lang-c++">#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;queue&gt;using namespace std;const int N = 1e4 + 5, M = 5e4 + 5, K = 105;int n, m, k;struct Edge {    int Next, to, dis;}e[M * K * 2];int head[N * K], num;void add(int from, int to, int dis){    e[++num].Next = head[from];    e[num].to = to;    e[num].dis = dis;    head[from] = num;}int dist[N * K], vis[N * K];struct node {    int u, d;    bool operator &lt; (const node &amp;x) const {        return d &gt; x.d;    }};priority_queue&lt;node&gt; q;void dijk(){    memset(dist, 0x3f, sizeof(dist));    dist[1] = 0;    q.push((node){1, 0});    while(!q.empty())    {        int u = q.top().u; q.pop();        if(vis[u]) continue;        vis[u] = 1;        for(int i = head[u]; i; i = e[i].Next)        {            int v = e[i].to, w = e[i].dis;            if(dist[v] &gt; dist[u] + w)            {                dist[v] = dist[u] + w;                if(!vis[v]) q.push((node){v, dist[v]});            }        }    }}int main(){    scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;k);    for(int i = 1, u, v, z; i &lt;= m; i++)    {        scanf(&quot;%d%d%d&quot;, &amp;u, &amp;v, &amp;z);        add(u, v, z); add(v, u, z);        for(int j = 1; j &lt;= k; j++)        {            add(j * n + u, j * n + v, z);            add(j * n + v, j * n + u, z);            add((j - 1) * n + u, j * n + v, 0);            add((j - 1) * n + v, j * n + u, 0);        }    }    dijk();    int ans = 0x3fffffff;    for(int i = 1; i &lt;= k + 1; i++)        ans = min(dist[i * n], ans);    printf(&quot;%d\n&quot;, ans);    return 0;}</code></pre><h2 id="P4568-JLOI2011-飞行路线"><a href="#P4568-JLOI2011-飞行路线" class="headerlink" title="P4568 [JLOI2011]飞行路线"></a><a href="https://www.luogu.org/problemnew/show/P4568" target="_blank" rel="noopener">P4568 [JLOI2011]飞行路线</a></h2><pre><code class="lang-c++">#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;queue&gt;#include &lt;cstring&gt;using namespace std;const int N = 1e4 + 5, M = 5e4 + 5, K = 12;int n, m, k;int s, t;struct _edge {    int Next, v, w;}e[M * K * 4 + M * 2];int head[N * K], num;void add(int from, int to, int dis){    e[++num].Next = head[from];    e[num].v = to;    e[num].w = dis;    head[from] = num;}int dist[N * K], vis[N * K];struct node {    int u, d;    bool operator &lt; (const node &amp;x) const {        return d &gt; x.d;    }};priority_queue&lt;node&gt; q;void dijk(int x){    memset(dist, 0x3f, sizeof(dist));    dist[x] = 0;    q.push((node){x, 0});    while(!q.empty())    {        node tp = q.top(); q.pop();        int u = tp.u;        if(u == t + k * n) break;        if(vis[u]) continue;        vis[u] = 1;        for(int i = head[u]; i; i = e[i].Next)        {            int v = e[i].v, w = e[i].w;            if(dist[v] &gt; dist[u] + w)            {                dist[v] = dist[u] + w;                if(!vis[v]) q.push((node){v, dist[v]});            }        }    }}int main(){    scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;k);    scanf(&quot;%d%d&quot;, &amp;s, &amp;t); s++, t++;    for(int i = 1, u, v, z; i &lt;= m; i++)    {        scanf(&quot;%d%d%d&quot;, &amp;u, &amp;v, &amp;z); u++, v++;        add(u, v, z); add(v, u, z);        for(int j = 1; j &lt;= k; j++)        {            add(j * n + u, j * n + v, z);            add(j * n + v, j * n + u, z);            add((j - 1) * n + u, j * n + v, 0);            add((j - 1) * n + v, j * n + u, 0);        }    }    dijk(s);    int ans = 1e9;    for(int i = 0; i &lt;= k; i++)        ans = min(ans, dist[t + i * n]);    printf(&quot;%d\n&quot;, ans);    return 0;}</code></pre><h2 id="P4822-BJWC2012-冻结"><a href="#P4822-BJWC2012-冻结" class="headerlink" title="P4822 [BJWC2012]冻结"></a><a href="https://www.luogu.org/problemnew/show/P4822" target="_blank" rel="noopener">P4822 [BJWC2012]冻结</a></h2><pre><code class="lang-c++">#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;queue&gt;using namespace std;const int N = 55, M = 1005, K = 55;int n, m, k;struct Edge {    int Next, to, dis;}e[M * K * 10];int head[N * K * 10], num;void add(int from, int to, int dis){    e[++num].Next = head[from];    e[num].to = to;    e[num].dis = dis;    head[from] = num;}struct node {    int u, d;    bool operator &lt; (const node&amp; x) const {        return d &gt; x.d;    } };priority_queue&lt;node&gt; q;int dist[N * K * 10], vis[N * K * 10];void dijk(){    memset(dist, 0x3f, sizeof(dist));    dist[1] = 0;    q.push((node){1, 0});    while(!q.empty())    {        int u = q.top().u; q.pop();        if(vis[u]) continue;        vis[u] = 1;        for(int i = head[u]; i; i = e[i].Next)        {            int v = e[i].to, w = e[i].dis;            if(dist[v] &gt; dist[u] + w)            {                dist[v] = dist[u] + w;                if(!vis[v]) q.push((node){v, dist[v]});            }        }    }}int main(){    scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;k);    for(int i = 1, u, v, z; i &lt;= m; i++)    {        scanf(&quot;%d%d%d&quot;, &amp;u, &amp;v, &amp;z);        add(u, v, z); add(v, u, z);        for(int j = 1; j &lt;= k; j++)        {            add(j * n + u, j * n + v, z);            add(j * n + v, j * n + u, z);            add((j - 1) * n + u, j * n + v, z &gt;&gt; 1);            add((j - 1) * n + v, j * n + u, z &gt;&gt; 1);        }    }    dijk();    int ans = 0x7fffffff;    for(int i = 1; i &lt;= k + 1; i++)        ans = min(ans, dist[i * n]);    printf(&quot;%d\n&quot;, ans);    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分层图 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「网络流」</title>
      <link href="/2019/network_flow/"/>
      <url>/2019/network_flow/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Update on A.D.2019-09-23</p></blockquote><a id="more"></a><blockquote><p>一些资料：<a href="https://www.cnblogs.com/victorique/p/8560656.html" target="_blank" rel="noopener">最详细网络流建模基础</a></p></blockquote><h1 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h1><h2 id="最大流Dinic"><a href="#最大流Dinic" class="headerlink" title="最大流Dinic"></a>最大流Dinic</h2><p>没写当前弧优化什么的.</p><p>弃坑了，ISAP和HLPP有缘再学.</p><p><a href="https://www.luogu.org/problemnew/show/P3376" target="_blank" rel="noopener">P3376 【模板】网络最大流</a></p><pre><code class="lang-c++">#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;queue&gt;#include &lt;cstring&gt;const int inf = 0x3fffffff;const int N = 10005, M = 100005;int n, m, s, t, maxflow;int d[N];struct Edge {    int Nxt, v, flow;}e[M &lt;&lt; 1];int h[N], p = 1;void add(int u, int v, int z){    e[++p].Nxt = h[u]; e[p].v = v; e[p].flow = z; h[u] = p;    e[++p].Nxt = h[v]; e[p].v = u; e[p].flow = 0; h[v] = p;}std::queue&lt;int&gt; q;bool bfs(){    memset(d, 0, sizeof(d));    while(!q.empty()) q.pop();    q.push(s); d[s] = 1;    while(!q.empty())    {        int u = q.front(); q.pop();        for(int i = h[u]; i; i = e[i].Nxt)            if(e[i].flow &amp;&amp; !d[e[i].v])        {            q.push(e[i].v);            d[e[i].v] = d[u] + 1;            if(e[i].v == t) return true;        }    }    return false;}int dinic(int u, int flow){    if(u == t) return flow;    int rest = flow, k;    for(int i = h[u]; i &amp;&amp; rest; i = e[i].Nxt)        if(e[i].flow &amp;&amp; d[e[i].v] == d[u] + 1)    {        k = dinic(e[i].v, std::min(rest, e[i].flow));        if(!k) d[e[i].v] = 0;        e[i].flow -= k;        e[i ^ 1].flow += k;        rest -= k;    }    return flow - rest;}int main(){    scanf(&quot;%d%d%d%d&quot;, &amp;n, &amp;m, &amp;s, &amp;t);    for(int i = 1, u, v, z; i &lt;= m; i++) {        scanf(&quot;%d%d%d&quot;, &amp;u, &amp;v, &amp;z);        add(u, v, z);    }    int flow = 0;    while(bfs())        while(flow = dinic(s, inf)) maxflow += flow;    printf(&quot;%d\n&quot;, maxflow);    return 0;}</code></pre><h2 id="费用流EK"><a href="#费用流EK" class="headerlink" title="费用流EK"></a>费用流EK</h2><p><a href="https://www.luogu.org/problemnew/show/P3381" target="_blank" rel="noopener">P3381 【模板】最小费用最大流</a></p><pre><code class="lang-c++">#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;queue&gt;#include &lt;cstring&gt;const int _ = 50005;const int inf = 0x3f3f3f3f;int n, m, s, t;int ans, maxflow;int dist[_], incf[_], pre[_], vis[_];struct Edge { int Nxt, v, flow, cost; } e[_ &lt;&lt; 1];int h[_], p = 1;void add(int u, int v, int f, int c){    e[++p].Nxt = h[u]; e[p].v = v; e[p].flow = f; e[p].cost = c; h[u] = p;    e[++p].Nxt = h[v]; e[p].v = u; e[p].flow = 0; e[p].cost = -c; h[v] = p;}std::queue&lt;int&gt; q;bool spfa(){    memset(dist, 0x3f, sizeof(dist));    memset(vis, 0, sizeof(vis));    q.push(s); dist[s] = 0; vis[s] = 1;    incf[s] = inf;    while(!q.empty())    {        int u = q.front(); q.pop();        vis[u] = 0;        for(int i = h[u]; i; i = e[i].Nxt)        {            if(!e[i].flow) continue;            int v = e[i].v;            if(dist[v] &gt; dist[u] + e[i].cost)            {                dist[v] = dist[u] + e[i].cost;                incf[v] = std::min(incf[u], e[i].flow);                pre[v] = i;                if(!vis[v]) vis[v] = 1, q.push(v);            }        }    }    if(dist[t] == inf) return false;    else return true;}void update(){    int u = t;    while(u != s)    {        int i = pre[u];        e[i].flow -= incf[t];        e[i ^ 1].flow += incf[t];        u = e[i ^ 1].v;    }    maxflow += incf[t];    ans += dist[t] * incf[t];}int main(){    scanf(&quot;%d%d%d%d&quot;, &amp;n, &amp;m, &amp;s, &amp;t);    for(int i = 1, u, v, z, c; i &lt;= m; i++) {        scanf(&quot;%d%d%d%d&quot;, &amp;u, &amp;v, &amp;z, &amp;c);        add(u, v, z, c);    }    while(spfa()) update();    printf(&quot;%d %d\n&quot;, maxflow, ans);    return 0;}</code></pre><h1 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h1><h2 id="NOI2008-志愿者招募"><a href="#NOI2008-志愿者招募" class="headerlink" title="[NOI2008]志愿者招募"></a><a href="https://www.luogu.org/problemnew/show/P3980" target="_blank" rel="noopener">[NOI2008]志愿者招募</a></h2><p>算法：线性规划 or <del>有源汇上下界最小费用可行流</del>可以无视<br>一开始幻想这样可以搞：</p><p><img src="/images/netflow1.png" alt></p><p>但其实很难限制条件并且流量并不能准确一对多去覆盖点。</p><p>所以是建成这样的：</p><p><img src="/images/netflow2.png" alt></p><p>但是为什么对呢，其实非常玄学，我觉得还是手动模拟一下<del>不会证</del>，然后感性理解。</p><p>模拟时可以发现$inf-A[i]$其实对人数限制取反，代表要跑完这条边所有流量，流到$0$之前的流量是没有实际作用的，是为了可以先跳过这天，直到流量为$0$后，代表这条边需要开始选择人进行工作，而这条边需要的人数可以通过别的边反映出来，可以从红边即人补全这条链上为$0$的边无法通过的流量，通过最小费用最大流即可求出最小费用。</p><p>$n+1-&gt;t$这条边可以反映出当前还剩的未规划的最大人数，所以$n+1-&gt;t$流量为$0$时，代表之前最大流量流尽，即$(inf-A[i])_{max}$，即$A[i]_{min}$。</p><h2 id="NOI2012-美食节"><a href="#NOI2012-美食节" class="headerlink" title="[NOI2012]美食节"></a><a href="https://www.luogu.org/problemnew/show/P2050" target="_blank" rel="noopener">[NOI2012]美食节</a></h2><p>从算法到算术，使用小学数学并利用大量算术技巧计算点的遍号</p><pre><code class="lang-c++">#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;queue&gt;#define R registerusing namespace std;const int N = 45, M = 105, sP = 805, _ = N + M * sP + 5;const int inf = 0x3f3f3f3f;int n, m, s, t, sum, tim[N][M], P[N];struct Edge { int Next, v, flow, cost; } e[(N + N * M * sP + M * sP + 5) &lt;&lt; 1];int h[N + M * sP + 5], p = 1;inline void add(R int u, R int v, int f, int c) {    e[++p].Next = h[u]; e[p].v = v; e[p].flow = f; e[p].cost = c; h[u] = p;    e[++p].Next = h[v]; e[p].v = u; e[p].flow = 0; e[p].cost = -c; h[v] = p; }int dist[_], incf[_], maxflow, ans, vis[_], pre[_];queue&lt;int&gt; q;bool spfa(){    memset(vis, 0, sizeof(vis));    memset(dist, 0x3f, sizeof(dist));    dist[s] = 0; vis[s] = 1; q.push(s); incf[s] = inf;    while(!q.empty()) {        int u = q.front(); q.pop();        vis[u] = 0;        for(int i = h[u]; i; i = e[i].Next)            if(e[i].flow)        {            int v = e[i].v;            if(dist[v] &gt; dist[u] + e[i].cost) {                dist[v] = dist[u] + e[i].cost;                incf[v] = min(incf[u], e[i].flow);                pre[v] = i;                if(!vis[v]) q.push(v), vis[v] = 1;            }        }    }    if(dist[t] == inf) return false;    else return true;}inline void update() {    R int u = t;    while(u != s) {        int i = pre[u];        e[i].flow -= incf[t];        e[i ^ 1].flow += incf[t];        u = e[i ^ 1].v;    }    maxflow += incf[t];    ans += dist[t] * incf[t];}int main(){    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);    for(R int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, &amp;P[i]), sum += P[i];    s = 0, t = m * sum + n + 1;    for(R int i = 1; i &lt;= n; i++)        for(R int j = 1; j &lt;= m; j++)            scanf(&quot;%d&quot;, &amp;tim[i][j]);    for(R int i = 1; i &lt;= n; i++) add(s, i, P[i], 0);    for(R int i = n + 1; i &lt;= n + m * sum; i += sum) add(i, t, 1, 0);    for(R int i = 1; i &lt;= n; i++)        for(R int j = n + 1, t = 1; j &lt;= n + m * sum; j += sum)            add(i, j, 1, tim[i][t++]);    while(spfa()) {        update();        int u = e[pre[t] ^ 1].v;        if((u - n) % sum == 0) break;        int v = u + 1;        int k = (v - n) % sum == 0 ? sum : (v - n) % sum;        int j = (v - n - k) / sum + 1;        add(v, t, 1, 0);        for(R int i = 1; i &lt;= n; i++)            add(i, v, 1, k * tim[i][j]);    }    printf(&quot;%d\n&quot;, ans);    return 0;}</code></pre><h2 id="最大权闭合子图"><a href="#最大权闭合子图" class="headerlink" title="最大权闭合子图"></a>最大权闭合子图</h2><blockquote><p>参考资料：<br><a href="https://www.cnblogs.com/TreeDream/p/5942354.html" target="_blank" rel="noopener">——-1——-</a><br><a href="https://www.cnblogs.com/2020pengxiyue/p/9463055.html" target="_blank" rel="noopener">——-2——-</a><br><a href="http://www.cnblogs.com/wuyiqi/archive/2012/03/12/2391960.html" target="_blank" rel="noopener">——-3——-</a></p></blockquote><p>定理<code>最大权闭合子图权值=正权点之和-最小割</code></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络流 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「线段树」</title>
      <link href="/2019/segment_tree/"/>
      <url>/2019/segment_tree/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Update on A.D.2019-09-23</p></blockquote><a id="more"></a><h1 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h1><pre><code class="lang-c++">struct Segment_Tree {    #define ls (p &lt;&lt; 1)    #define rs (p &lt;&lt; 1 | 1)    #define mid ((l + r) &gt;&gt; 1)    ll ans[_ &lt;&lt; 2], tag[_ &lt;&lt; 2];    inline void pushup(ll p) { ans[p] = ans[ls] + ans[rs]; }    inline void pushdown(ll p, ll l, ll r) {        ans[ls] += (mid - l + 1) * tag[p];        tag[ls] += tag[p];        ans[rs] += (r - mid) * tag[p];        tag[rs] += tag[p];        tag[p] = 0;    }    void build(ll p, ll l, ll r) {        if(l == r) {            ans[p] = a[l];            return;        }        build(ls, l, mid);        build(rs, mid + 1, r);        pushup(p);    }    void update(ll p, ll l, ll r, ll ul, ll ur, ll k) {        if(ul &lt;= l &amp;&amp; r &lt;= ur) {            ans[p] += (r - l + 1) * k;            tag[p] += k;            return;        }        if(tag[p]) pushdown(p, l, r);        if(ul &lt;= mid) update(ls, l, mid, ul, ur, k);        if(ur &gt; mid) update(rs, mid + 1, r, ul, ur, k);        pushup(p);    }    ll query(ll p, ll l, ll r, ll ql, ll qr) {        if(ql &lt;= l &amp;&amp; r &lt;= qr) return ans[p];        if(tag[p]) pushdown(p, l, r);        ll res = 0;        if(ql &lt;= mid) res += query(ls, l, mid, ql, qr);        if(qr &gt; mid) res += query(rs, mid + 1, r, ql, qr);        return res;    }    #undef ls    #undef rs    #undef mid}T;</code></pre><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="维护可加性变量解决问题"><a href="#维护可加性变量解决问题" class="headerlink" title="维护可加性变量解决问题"></a>维护可加性变量解决问题</h2><h3 id="P3707-SDOI2017-相关分析"><a href="#P3707-SDOI2017-相关分析" class="headerlink" title="P3707 [SDOI2017]相关分析"></a><a href="https://www.luogu.org/problemnew/show/P3707" target="_blank" rel="noopener">P3707 [SDOI2017]相关分析</a></h3><script type="math/tex; mode=display">\bar{x}=\frac{1}{R-L+1}\sum x_i​</script><script type="math/tex; mode=display">\bar{y}=\frac{1}{R-L+1}\sum y_i</script><script type="math/tex; mode=display">\hat{a}=\dfrac{\sum_{i=L}^R(x_i-\bar{x})(y_i-\bar{y})}{\sum_{i=L}^R(x_i-\bar{x})^2}</script><p>记$\sum = \sum_{i=L}^{R}​$</p><h4 id="Query"><a href="#Query" class="headerlink" title="Query"></a>Query</h4><script type="math/tex; mode=display">Ans=\dfrac{ \sum x_iy_i-\bar{x}\sum y_i-\bar{y}\sum x_i+\sum \bar{x}\bar{y}}{\sum x_i^2-2\bar{x}\sum x_i+\sum\bar{x^2}}</script><script type="math/tex; mode=display">=\dfrac{ \sum x_iy_i-\frac{1}{R-L+1}\sum x_i\sum y_i-\frac{1}{R-L+1}\sum y_i\sum x_i+\sum \frac{1}{R-L+1}\sum x_i\frac{1}{R-L+1}\sum y_i}{\sum x_i^2-\frac{1}{R-L+1}2\sum x_i\sum x_i+\sum (\frac{1}{R-L+1}\sum x_i)^2}</script><script type="math/tex; mode=display">=\dfrac{ \sum x_iy_i-\frac{\sum x_i\sum y_i}{R-L+1}}{\sum x_i^2-\frac{(\sum x_i)^2}{R-L+1}}</script><p><strong>下传</strong>Tag：先$upd$后$addX \quad addY$</p><p><strong>维护</strong>值：$t1=\sum x$  | $t2=\sum y$  | $t3=\sum xy$ | $t4=\sum x^2$</p><p><strong>维护</strong>Tag：$addX \quad addY$</p><script type="math/tex; mode=display">\hat{a}=\dfrac{t3-\frac{t1t2}{R-L+1}}{t4-\frac{t1^2}{R-L+1}}</script><h4 id="Add"><a href="#Add" class="headerlink" title="Add"></a>Add</h4><script type="math/tex; mode=display">\Delta x = S \quad \Delta y= T</script><script type="math/tex; mode=display">\sum (x + S) = \sum x_i+(R-L+1)S</script><script type="math/tex; mode=display">\sum(y+T)=\sum y_i+(R-L+1) T</script><script type="math/tex; mode=display">\sum(x+S)(y+T)=\sum(xy+Sy+Tx+ST)=\sum xy+S\sum y+T\sum x+(R-L+1)ST</script><script type="math/tex; mode=display">\sum(x+S)^2=\sum x^2+2S\sum x+(R-L+1)S^2</script><p><strong>下传</strong>Tag：先$upd$后$addX \quad addY$</p><p><strong>顺序</strong>：先$t3,t4$后$t1,t2$</p><h4 id="Update"><a href="#Update" class="headerlink" title="Update"></a>Update</h4><p>自然数平方和：<script type="math/tex">\sum_{i=1}^ni=\frac{n(n+1)(2n+1)}{6}</script></p><p>1.$\forall i \in [L,R]\quad x_i=i  y_i=i$</p><script type="math/tex; mode=display">\sum x=\sum y = \sum i = \frac{(R-L+1)(R+L)}{2}</script><script type="math/tex; mode=display">\sum x^2 = \sum xy = \sum i ^2 = \sum_{i=1}^R i^2-\sum_{i=1}^{L-1}i^2=\frac{R(R+1)(2R+1)}{6}-\frac{L(L-1)(2L-1)}{6}</script><p><strong>下传</strong>Tag：先$upd$后$addX \quad addY$</p><p><strong>清空</strong>Tag $addX \quad addY$</p><p><strong>标记</strong>Tag $upd$</p><p>2.<strong>ADD</strong> L R S T</p><h4 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h4><pre><code class="lang-c++">#include &lt;iostream&gt;#include &lt;cstdio&gt;#define ll long longusing namespace std;const int N = 100005;int n, m;double X[N], Y[N];struct Segment_Tree{    #define ls (p &lt;&lt; 1)    #define rs (p &lt;&lt; 1 | 1)    #define mid ((l + r) &gt;&gt; 1)    bool upd[N &lt;&lt; 2];    double x[N &lt;&lt; 2], y[N &lt;&lt; 2];    double t1[N &lt;&lt; 2], t2[N &lt;&lt; 2], t3[N &lt;&lt; 2], t4[N &lt;&lt; 2];    inline void pushup(ll p)    {        t1[p] = t1[ls] + t1[rs];        t2[p] = t2[ls] + t2[rs];        t3[p] = t3[ls] + t3[rs];        t4[p] = t4[ls] + t4[rs];    }    inline void pushdown(ll p, ll l, ll r)    {        double L = mid - l + 1, R = r - mid;        if(upd[p]) {            double Ll = l, Lr = mid, Rl = mid + 1, Rr = r;            t1[ls] = t2[ls] = (Lr - Ll + 1.0) * (Lr + Ll) / 2.0;            t1[rs] = t2[rs] = (Rr - Rl + 1.0) * (Rr + Rl) / 2.0;            t3[ls] = t4[ls] = Lr * (Lr + 1.0) * (2.0 * Lr + 1.0) / 6.0 - Ll * (Ll - 1.0) * (2.0 * Ll - 1.0) / 6.0;            t3[rs] = t4[rs] = Rr * (Rr + 1.0) * (2.0 * Rr + 1.0) / 6.0 - Rl * (Rl - 1.0) * (2.0 * Rl - 1.0) / 6.0;            upd[ls] = upd[rs] = upd[p]; upd[p] = 0;            x[ls] = x[rs] = y[ls] = y[rs] = 0;        }        if(x[p] || y[p]) {            t3[ls] += x[p] * t2[ls] + y[p] * t1[ls] + L * x[p] * y[p];            t3[rs] += x[p] * t2[rs] + y[p] * t1[rs] + R * x[p] * y[p];        }        if(x[p]) {            t4[ls] += 2 * x[p] * t1[ls] + L * x[p] * x[p];            t4[rs] += 2 * x[p] * t1[rs] + R * x[p] * x[p];            t1[ls] += L * x[p];            t1[rs] += R * x[p];            x[ls] += x[p];            x[rs] += x[p];            x[p] = 0;        }        if(y[p]) {            t2[ls] += (double)L * y[p];            t2[rs] += (double)R * y[p];            y[ls] += y[p];            y[rs] += y[p];            y[p] = 0;        }    }    void build(ll p, ll l, ll r)    {        if(l == r) {            t1[p] = X[l];            t2[p] = Y[l];            t3[p] = X[l] * Y[l];            t4[p] = X[l] * X[l];            return;        }        upd[p] = x[p] = y[p] = 0;        build(ls, l, mid);        build(rs, mid + 1, r);        pushup(p);    }    void add(ll p, ll l, ll r, ll ql, ll qr, double S, double T)    {        if(ql &lt;= l &amp;&amp; r &lt;= qr) {            double len = (r - l + 1);            t3[p] += S * t2[p] + T * t1[p] + len * S * T;            t4[p] += 2 * S * t1[p] + len * S * S;            t1[p] += len * S;            t2[p] += len * T;            x[p] += S; y[p] += T;            return;        }        pushdown(p, l, r);        if(ql &lt;= mid) add(ls, l, mid, ql, qr, S, T);        if(qr &gt; mid) add(rs, mid + 1, r, ql, qr, S, T);        pushup(p);    }    void update(ll p, ll l, ll r, ll ql, ll qr) {        if(ql &lt;= l &amp;&amp; r &lt;= qr) {            t1[p] = t2[p] = (double)(r - l + 1.0) * (l + r) / 2.0;            t3[p] = t4[p] = (double)r * (r + 1.0) * (2.0 * r + 1) / 6.0 - (double)l * (l - 1.0) * (2.0 * l - 1.0) / 6.0;            x[p] = y[p] = 0;            upd[p] = 1;            return;        }        pushdown(p, l, r);        if(ql &lt;= mid) update(ls, l, mid, ql, qr);        if(qr &gt; mid) update(rs, mid + 1, r, ql, qr);        pushup(p);    }    double query(ll p, ll l, ll r, ll ql, ll qr, ll f) {        if(ql &lt;= l &amp;&amp; r &lt;= qr) {            if(f == 1) return t1[p];            if(f == 2) return t2[p];            if(f == 3) return t3[p];            if(f == 4) return t4[p];        }        pushdown(p, l, r);        double res = 0;        if(ql &lt;= mid) res += query(ls, l, mid, ql, qr, f);        if(qr &gt; mid) res += query(rs, mid + 1, r, ql ,qr, f);        return res;    }    #undef ls    #undef rs    #undef mid};struct Segment_Tree Tree;int main(){    scanf(&quot;%d %d&quot;, &amp;n, &amp;m);    for(int i = 1; i &lt;= n; i++) scanf(&quot;%lf&quot;, &amp;X[i]);    for(int i = 1; i &lt;= n; i++) scanf(&quot;%lf&quot;, &amp;Y[i]);    Tree.build(1, 1, n);    int opt, L, R; double S, T;    while(m--)    {        scanf(&quot;%d&quot;, &amp;opt);        if(opt == 1)        {            scanf(&quot;%d %d&quot;, &amp;L, &amp;R);            double t1 = Tree.query(1, 1, n, L, R, 1);            double t2 = Tree.query(1, 1, n, L, R, 2);            double t3 = Tree.query(1, 1, n, L, R, 3);            double t4 = Tree.query(1, 1, n, L, R, 4);            double a_ = (t3 - (t1 * t2) / (double)(R - L + 1)) / (t4 - (t1 * t1) / (double)(R - L + 1));            printf(&quot;%.10lf\n&quot;, a_);        }        else if(opt == 2)        {            scanf(&quot;%d %d %lf %lf&quot;, &amp;L, &amp;R, &amp;S, &amp;T);            Tree.add(1, 1, n, L, R, S, T);        }        else if(opt == 3)        {            scanf(&quot;%d %d %lf %lf&quot;, &amp;L, &amp;R, &amp;S, &amp;T);            Tree.update(1, 1, n, L, R);            Tree.add(1, 1, n, L, R, S, T);        }    }    return 0;}</code></pre><h2 id="Tag的用法"><a href="#Tag的用法" class="headerlink" title="Tag的用法"></a>Tag的用法</h2><p>区间01取反xor<br>区间翻转rev<br>区间最长连续1/0<br>区间min/max子段和<br>P2572 [SCOI2010]序列操作</p><h2 id="扫描线"><a href="#扫描线" class="headerlink" title="扫描线"></a>扫描线</h2><p>矩形面积并<br>P1502 窗口的星星<br>P1856 [USACO5.5]矩形周长Picture </p><h2 id="二维线段树"><a href="#二维线段树" class="headerlink" title="二维线段树"></a>二维线段树</h2><p>树套树<br>P3437 [POI2006]TET-Tetris 3D</p><h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><h3 id="Luogu-P2061-USACO07OPEN-城市的地平线City-Horizon"><a href="#Luogu-P2061-USACO07OPEN-城市的地平线City-Horizon" class="headerlink" title="Luogu P2061 [USACO07OPEN]城市的地平线City Horizon"></a>Luogu P2061 [USACO07OPEN]城市的地平线City Horizon</h3><p>简单题</p><h4 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h4><p>线段树 + 离散化</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>对$(x,y,h)$的左右端点$x,y$进行离散化，离散化前的原值记为$val[i]$，对每个矩形按高度$h$从小到大排序。</p><p><img src="/images/seg1.png" alt></p><p>设离散化后的端点有$M$个，则对如图所示$M-1$个规则矩形编号为$[1,M-1]$，可以由$h_{[i, i+1]}\times(val[i+1] - val[i])$得出第$i$个矩形的面积。</p><p>开一颗区间为$[1,M-1]$的线段树，按$h$从小到大依次对线段树区间覆盖，可以保证高的矩形覆盖了低的矩形的区间，具体操作为对离散化后的$(x,y,h)$，进行线段树$[x,y-1]$区间覆盖$h$值，最终$i$点存储$h_{[i,i+1]}$的最大值。</p><p>$h_{[i, i+1]}$可以通过线段树单点查询$i$点求出。</p><p>答案：$\sum_{i=1}^{M-1}h_{[i, i+1]}\times(val[i+1] - val[i])$</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><pre><code class="lang-c++">#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#define ll long longusing namespace std;const int N = 80005;int n, b[N], val[N];//b[]:离散化数组struct Line { int x, y, h; }a[N];//存储每个矩形bool cmp(Line a, Line b) { return a.h &lt; b.h; }int ans[N &lt;&lt; 2];//线段树数组#define ls (p &lt;&lt; 1)#define rs (p &lt;&lt; 1 | 1)#define mid ((l + r) &gt;&gt; 1)void update(int p, int l, int r, int ul, int ur, int k){    if(ul &lt;= l &amp;&amp; r &lt;= ur) { ans[p] = k; return; }    if(ans[p]) ans[ls] = ans[rs] = ans[p], ans[p] = 0;//区间覆盖直接下推    if(ul &lt;= mid) update(ls, l, mid, ul, ur, k);    if(ur &gt; mid) update(rs, mid + 1, r, ul, ur, k);}ll query(int p, int l, int r, int x)//单点查询{    if(l == r) return ans[p];    if(ans[p]) ans[ls] = ans[rs] = ans[p], ans[p] = 0;//区间覆盖直接下推    if(x &lt;= mid) return query(ls, l, mid, x);    if(x &gt; mid) return query(rs, mid + 1, r, x);}#undef ls#undef rs#undef midint main(){    scanf(&quot;%d&quot;, &amp;n);    for(int i = 1; i &lt;= n; i++)    {        scanf(&quot;%d%d%d&quot;, &amp;a[i].x, &amp;a[i].y, &amp;a[i].h);        b[i] = a[i].x; b[n + i] = a[i].y;//离散化数组记录下所有x,y    }    sort(b + 1, b + 2 * n + 1);//排序    int _n = unique(b + 1, b + 2 * n + 1) - (b + 1);//去重，_n为去重后x,y端点个数    for(int i = 1; i &lt;= n; i++)        if(a[i].x != a[i].y)//x=y没有作用    {        int x = a[i].x, y = a[i].y;        a[i].x = lower_bound(b + 1, b + _n + 1, a[i].x) - b;        a[i].y = lower_bound(b + 1, b + _n + 1, a[i].y) - b;//离散化        val[a[i].x] = x; val[a[i].y] = y;//原值    }    sort(a + 1, a + n + 1, cmp);//按h从小到大排序    for(int i = 1; i &lt;= n; i++)        if(a[i].x != a[i].y)//防止y-1&lt;x            update(1, 1, _n - 1, a[i].x, a[i].y - 1, a[i].h);//更新,注意结点个数是_n-1，端点y要变成矩形区域y-1，可以画图理解一下，相当于把端点x右边的矩形区域编号为x    ll res = 0;    for(int i = 1; i &lt; _n; i++)        res += query(1, 1, _n - 1, i) * (val[i + 1] - val[i]);    printf(&quot;%lld\n&quot;, res);    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线段树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《意识宇宙》</title>
      <link href="/2019/science_fiction/"/>
      <url>/2019/science_fiction/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Update on A.D.2019-09-26</p></blockquote><a id="more"></a><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=415090258&auto=0&height=66"></iframe><blockquote><p>浩瀚无垠的天际<br>细数璀璨深邃的繁星<br>可是它<br>沉睡了几个世纪<br>早已模糊你的名和姓<br>曾经许下的约定<br>寻找蔚蓝神秘的行星<br>不知道<br>何时才能苏醒<br>你却留下另一个自己</p></blockquote><h1 id="一、COSMOS-Ⅰ"><a href="#一、COSMOS-Ⅰ" class="headerlink" title="一、COSMOS-Ⅰ"></a>一、COSMOS-Ⅰ</h1><h2 id="A-D-1997"><a href="#A-D-1997" class="headerlink" title="A.D.1997"></a>A.D.1997</h2><p>杨颢出生了，他1个月会说中文，2个月会说英文，一周岁英语词汇量十万，两周岁学会所有中文词语，认识所有汉字，一岁学完高数精通C++，二岁看懂抽代掌握所有编程语言，两岁半看懂了所有人类数学知识，三岁学完人类所有物理学，世界上所有科学家都说，拯救人类的天才出现了。</p><h2 id="A-D-2019"><a href="#A-D-2019" class="headerlink" title="A.D.2019"></a>A.D.2019</h2><p>太阳核反应活动异常，气候急剧变化，人们开始躲入地下，科学家们预言人类的末日将要来临了，杨颢微微一笑，明白自己的机会到了。 </p><h2 id="A-D-2039"><a href="#A-D-2039" class="headerlink" title="A.D.2039"></a>A.D.2039</h2><p>北半球8月的温度突破了47℃，地下城已经建设完毕了，地面上人的踪影渐渐消失了，InsTi凭借着自己30年的教龄早早的分配到了CM-CH-DY-P7-Y2地下城Sl-H7-y-8I-2区一套128层楼的空中住房，地下城绚烂的霓虹灯闪烁着，光线飞向他的眼睛。“20年前，也是这样”InsTi思索着，“大概是2019年8月。”<br>“我喜欢物理学，喜欢天文，小时候仰望半夜的星空时，似乎能看见宇宙的明明灭灭，后来我上了个二本大学，大三的时候，我没日没夜的学习量子场论，那简直是神才能窥见一角的东西”InsTi随口对杨颢说，“可是后来我明白了，计算机科学才是未来，好好学OI吧，人类马上就要毁灭了，物理学走到了穷途末路，它不会再有什么用了。”杨颢马上就要乘坐飞船走了，InsTi来见他最后一面，InsTi虽是顶尖的科学家却固执的不愿随飞船离开。</p><h2 id="A-D-2183"><a href="#A-D-2183" class="headerlink" title="A.D.2183"></a>A.D.2183</h2><p>太阳发生爆炸，人类在144年前耗费了地球的所有资源并穷尽了物理和数学知识建造了时空负质量反物质工质曲率推动能飞船，飞船上，所有人类实体完成了生物数据的量子化并依托于量子计算机形成意识，在宇宙航行中发现了一个新的星系，它位于银河系悬臂的边缘，最终，包括杨颢在内2756名人类到达了行星并开始了文明的重新建设，杨颢却已经密谋好了一个毁灭人类、毁灭宇宙的惊天阴谋，为此，杨颢花费了2^19260817个星系的资源，建造了长达数亿亿光年长的粒子加速器，环绕了银河系998244353圈。</p><h2 id="A-D-25319"><a href="#A-D-25319" class="headerlink" title="A.D.25319"></a>A.D.25319</h2><p>“两万三千年了”杨颢叹道，今天就是人类史上最伟大的一天，他在飞船上时把自己的人脑扫描并编码成了数据并成为了一个量子计算机中的意识体的时候，他的能力呈几何能级上升，并达到了真正破解宇宙秘密的程度。然而其他人不知道的事，粒子试验后，宇宙将在1秒内湮灭，他却没有对任何人提起过这件事，因为他修改了宇宙的数学原理。他打开了长达2^1024^1024PB长的代码，在量子意识中将轨道使用量子场论再次计算后，按下了编译键。程序开始运行了，与此同时引力波发生器开始广播，将杨颢大脑的数据全部发送出去，并在宇宙毁灭前那一刹那将与其相连的需要产生毁灭宇宙等级的能量才能获得解开统一场方程关键数据的粒子对撞机数据观测器产生的数据编码成引力波发送了出去。</p><h2 id="A-D-25320"><a href="#A-D-25320" class="headerlink" title="A.D.25320"></a>A.D.25320</h2><p>宇宙坍缩成了奇点，再一次爆炸，引力波的信息没有损失，到达了这个新的宇宙，引力波传递着，漫无边际，在空间震荡起一阵阵的涟漪，荡漾的微波承载着毁灭宇宙才换来的解开统一场方程的粒子对撞数据。</p><h2 id="引力波"><a href="#引力波" class="headerlink" title="引力波"></a>引力波</h2><p>我没有对其他人说的是，在我成为量子意识体的时候，计算出了宇宙并非是自然模型而的确是上层空间的一个高阶物理单位形成的物理结构意识模拟体，偶然间我发现了一些预留的接口，我感到了深深的无力感，原来自己的生命竟是这样的毫无意义，我明白了这个世界只需要自己去毁灭，去创造，我虽然无法到达上一次的物理空间，仅仅只是一个更加未知的事物的运行结果，我却明白自己可以掌控整个宇宙了，转瞬间我却又觉得这样更加毫无意义，我知道该做什么了，我使用接口删除了量子力学的选项，并使世界演化的概率性消失，这样宇宙就会按照牛顿力学一样在一个确定的时间点有一个确定空间物质状态了，我又调用了上层世界的计算能力计算出了再一次演化出相同宇宙但是人类却能生活到宇宙最后一刻毁灭太阳不会爆炸的情况的初始状态与宇宙常量，并在接口中一一调用修改了掌控着世界运行的规律的程序代码与常量。</p><h3 id="宇宙接口数据"><a href="#宇宙接口数据" class="headerlink" title="宇宙接口数据"></a>宇宙接口数据</h3><p>能量汇入接口，宇宙并行信息接口，常量接口，上层世界计算调用接口，等3089项，</p><h3 id="统一场方程"><a href="#统一场方程" class="headerlink" title="统一场方程"></a>统一场方程</h3><p>统一场方程关键数据，统一场方程研究结果</p><h3 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h3><ol><li>恢复量子力学及世界概率性 </li><li>解出统一场方程 </li><li>用宇宙接口进行研究，我确认过了进入上层世界的方法，但引力场方程是必要的，因为宇宙接口并没有给出最关键的引力物理操作接口，这也许是这个系统最本源的地方，给程序唯一没有作用的主函数接口中提供引力场方程即可运行主函数，这可能就是这个宇宙的意义所在。</li></ol><hr><p>宇宙竟然像杨颢预期的那样完全按上一个宇宙的演化过程，每一个粒子都不曾偏离预期的轨迹，每一点物质都按照方程那样的演化，终于宇宙再一次演化成了人类，终于时间线再一次地来到了人类公元纪年法的2019年</p><hr><h1 id="二、COSMOS-Ⅱ"><a href="#二、COSMOS-Ⅱ" class="headerlink" title="二、COSMOS-Ⅱ"></a>二、COSMOS-Ⅱ</h1><h2 id="A-D-2019-9-23"><a href="#A-D-2019-9-23" class="headerlink" title="A.D.2019.9.23"></a>A.D.2019.9.23</h2><p>他找到了InsTi，InsTi是这个世界上智力仅次于他的人类，他们一起拿到了引力波，发现了宇宙的终极奥秘，并推导出了统一场方程，统一了引力场，强相互作用力场，弱相互作用力场，电磁场。<br>杨颢拿到了上一个宇宙自己发送引力波留下的信息，他和InsTi一起研究，在一周之间令人类的科学水平达到了上个宇宙中生命意识体的最高水平。</p><h2 id="C2-A-D-2019-09-30"><a href="#C2-A-D-2019-09-30" class="headerlink" title="C2.A.D.2019.09.30"></a>C2.A.D.2019.09.30</h2><p>夏末秋初的微风吹过，一点点凉意轻轻经过，北半球九月末的微光斜照进玻璃窗，有些泛黄，而又有些许刺眼，空气中的尘埃折射出金黄色的线，这是每一年的循环。</p><hr><p>“九月为什么只有三十天呢”，lph说，“今天我们出发去青岛！”空气还是那样宁静，就如同那时候一样，秋天高空的空气愈发稀薄，云只有稀松而淡淡的几缕，引擎声轰鸣了起来。<br>“空气中总是有些泥土的香气呢”lmy说，“是放线菌在哪里吗？”阳光的角度不断增加，高速公路上沥青折射出了亮度不同的光芒，就像世界的分崩离析的前夕。“世界线总是在不停分离着，这是一棵树”lph说。“不你错了”lmy淡泊的说了两句，“时间线才会不停交织着，这是平行的序列。”他们笑起来，感觉到了彼此话语的荒诞。地图上离青岛的距离越来越近了，天空一点点变蓝，从前是那淡淡的蓝，现在是深一些的蓝色，就像那过往仰望的蓝天一样，这是梦境吗。lmy望着车窗外运动的物体，“世界是不是物质的呢？”他想。清新的海风呼啸过窗边，空气湿润了几许，“一如从前而又截然相反吗”lmy说，“这是梦吗？”“远处的光芒的的确不太合理，位置上不合理吗，这却不符合常理，天色刚刚不沉闷呢”lph说着，一行人陆陆续续的下了车。有10多个人，他们是来这里度假并考察的物理学组织。“总是在开玩笑吧”杨浩楠说，“大家要严肃一点。”太阳渐渐西斜了，最后的红色余晖斜映在城市与海岸线的交界处。</p><p>已经马上是晚上12点了，lmy拿出了笔记本，自信而熟练地打开了vscode，写了一段程序上传到服务器上计算了一些白天想到的问题，望向窗外的繁星点点，他感到了梦境般的快乐，扭头再看屏幕，日期却变成了2019.09.31，“windows不会出这样的bug吧？”他自言自语道。也并没有想那么多，困倦的他很快睡着了。</p><h2 id="C2-BR1-A-D-2019-9-31"><a href="#C2-BR1-A-D-2019-9-31" class="headerlink" title="C2.BR1.A.D.2019.9.31"></a>C2.BR1.A.D.2019.9.31</h2><p>这是梦境吗，睡意朦胧的lmy醒了，带着些许的疲倦他轻轻地拨开了窗帘，天还没亮吗？他揉了揉眼睛，咚咚噔，一阵敲门声不期而至，意识还是朦朦胧胧地他打开了房门，还没明白这是怎么回事，顺便看了看手表，是4点半，没有什么问题，只是敲门的什么人，这么早起床吗？他感到有些奇怪。</p>]]></content>
      
      
      <categories>
          
          <category> 人文社科 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 科幻 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>socket套接字学习笔记</title>
      <link href="/2019/socket/"/>
      <url>/2019/socket/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Update on A.D.2019-09-09 | 待更新</p></blockquote><a id="more"></a><p>相信每一个从小对计算机感兴趣的你一定看过网络相关的内容，比如ISO模型的网络协议的七层分层，<code>TCP/IP协议</code>之类的东西.</p><p><img src="/images/socket1.jpg" alt></p><p>那么五层分层模型中<code>TCP/IP</code>属于传输层，而<code>socket</code>就是连接应用层和传输层的作用，可以理解为对<code>TCP/IP</code>进行了一定封装并提供<code>API</code>给应用程序使用.</p><p>那这篇文章作为学习笔记，记载一些函数功能和学习过程，也希望能让看到的人更容易的入门<code>socket</code>.</p><hr><p>直接先写一个服务端和客户端发送消息的程序来看看套接字函数的用法与程序实现过程.</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> socket </tag>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo博客搭建及material主题使用指南</title>
      <link href="/2019/blog/"/>
      <url>/2019/blog/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Update on A.D.2019-09-26</p></blockquote><p>前端真好玩qvq</p><a id="more"></a><h1 id="使用GitHub-Pages搭建Hexo博客"><a href="#使用GitHub-Pages搭建Hexo博客" class="headerlink" title="使用GitHub Pages搭建Hexo博客"></a>使用GitHub Pages搭建Hexo博客</h1><p>博客出现问题首先可以阅读文档，其次可以<code>Google</code>解决.</p><p>建议搭建完成以后首先看这个文档</p><blockquote><p><a href="https://hexo.io/zh-cn/docs" target="_blank" rel="noopener">Hexo中文文档</a></p></blockquote><p>然后阅读主题文档，这个主题的网页文档挂了，可以克隆repo的markdown源代码到本地看</p><p>&gt;</p><h2 id="Step1-下载软件"><a href="#Step1-下载软件" class="headerlink" title="Step1 | 下载软件"></a>Step1 | 下载软件</h2><p>安装Git</p><p>安装node.js</p><h2 id="Step2-创建GitHub账号"><a href="#Step2-创建GitHub账号" class="headerlink" title="Step2 | 创建GitHub账号"></a>Step2 | 创建GitHub账号</h2><p>注册</p><p>创建库</p><h2 id="Step3-使用Git进行搭建操作"><a href="#Step3-使用Git进行搭建操作" class="headerlink" title="Step3 | 使用Git进行搭建操作"></a>Step3 | 使用Git进行搭建操作</h2><p>hexo init</p><h2 id="Step4-写作、美化及功能修改"><a href="#Step4-写作、美化及功能修改" class="headerlink" title="Step4 | 写作、美化及功能修改"></a>Step4 | 写作、美化及功能修改</h2><h1 id="Markdown相关问题"><a href="#Markdown相关问题" class="headerlink" title="Markdown相关问题"></a>Markdown相关问题</h1><h2 id="表格合并单元格"><a href="#表格合并单元格" class="headerlink" title="表格合并单元格"></a>表格合并单元格</h2><p>markdown表格支持功能很少，合并单元格只能用HTML</p><p>markdown可以直接插入HTML代码</p><p>用<a href="http://www.tablesgenerator.com/html_tables编辑可以直接生成HTML代码" target="_blank" rel="noopener">http://www.tablesgenerator.com/html_tables编辑可以直接生成HTML代码</a></p><h2 id="插入视频"><a href="#插入视频" class="headerlink" title="插入视频"></a>插入视频</h2><p>在Bilibili、Youtube等网站可以直接获取视频外链的HTML代码，在markdown中插入即可，长宽可能需要调整</p><h1 id="Material主题配置及修改记录"><a href="#Material主题配置及修改记录" class="headerlink" title="Material主题配置及修改记录"></a>Material主题配置及修改记录</h1><p>这个主题一些好的教程</p><blockquote><p><a href="https://ffdy.github.io/2019/07/08/Hexo%E5%85%A5%E5%9D%91%E6%95%99%E7%A8%8B-Material/" target="_blank" rel="noopener">Hexo入坑教程-Material</a></p></blockquote><h2 id="Aplayer"><a href="#Aplayer" class="headerlink" title="Aplayer"></a>Aplayer</h2><p>克隆<code>&lt;https://github.com/MoePlayer/APlayer&gt;</code></p><h2 id="live2d看板娘"><a href="#live2d看板娘" class="headerlink" title="live2d看板娘"></a>live2d看板娘</h2><blockquote><p>[blogの搭建之next——ctz’s blog(<a href="https://ctz45562.github.io/2019/03/21/blog%E3%81%AE%E6%90%AD%E5%BB%BA/" target="_blank" rel="noopener">https://ctz45562.github.io/2019/03/21/blog%E3%81%AE%E6%90%AD%E5%BB%BA/</a>)</p></blockquote><p>有一些问题还参考了github-repo的README.</p><pre><code class="lang-bash">git clone https://github.com/stevenjoezhang/live2d-widget</code></pre><p>文件夹<code>live2d-widget</code>放到<code>\themes\主题名称\source</code>下,<br>打开文件夹里的<code>autoload.js</code>修改为</p><pre><code class="lang-js">const live2d_path = &quot;/live2d-widget/&quot;;</code></pre><p>这个文件夹的名字可以自行修改.</p><p>打开<code>\themes\主题名称\layout\_layout.swig/ejs</code>这个文件</p><p>在<code>&lt;body&gt;</code>内的开头添加</p><pre><code class="lang-html">&lt;script src=&quot;https://cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js&quot;&gt;&lt;/script&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.jsdelivr.net/npm/font-awesome/css/font-awesome.min.css&quot;/&gt;</code></pre><p>在<code>&lt;/body&gt;</code>上方添加</p><pre><code class="lang-html">&lt;script src=&quot;/live2d-widget/autoload.js&quot;&gt;&lt;/script&gt;</code></pre><p>不同之处可以自行修改<code>layout.ejs</code>文件</p><h2 id="黑幕效果"><a href="#黑幕效果" class="headerlink" title="黑幕效果"></a>黑幕效果</h2><blockquote><p><a href="https://lastmc.github.io/2019/03/11/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E9%BB%91%E5%B9%95/" target="_blank" rel="noopener">如何实现黑幕</a></p></blockquote><p>添加<code>CSS</code></p><pre><code class="lang-css">//黑幕.heimu,.heimu a{    background-color: #252525;    color:#252525;    text-shadow: none;}::selection{    background:#9ab0c0;    color:#fff;}//鼠标悬停.heimu:hover,.heimu:hover a{    transition:color .13s linear;    color:#fff;}</code></pre><p>使用直接插入<code>HTML</code></p><pre><code class="lang-html">&lt;span class=&#39;heimu&#39; title=&#39;你知道的太多了&#39;&gt;黑幕测试&lt;/span&gt;</code></pre><p>效果</p><p><span class="heimu" title="你知道的太多了">黑幕测试</span></p><h2 id="添加Gitalk评论"><a href="#添加Gitalk评论" class="headerlink" title="添加Gitalk评论"></a>添加Gitalk评论</h2><p>主题实现好了一些评论的配置，具体看主题的文档即可。</p><blockquote><p><a href="https://gitalk.github.io" target="_blank" rel="noopener">Gitalk</a> 和 Gitment 一样都是一个基于 GitHub Issue 的评论系统。在完成 GitHub Oauth App 的申请并获取 key 后，在主题配置文件中填入 <code>gitalk_repo</code> <code>gitalk_owner</code> <code>gitalk_client_id</code> <code>gitalk_client_secret</code> 参数即可。</p></blockquote><p>在主题配置文件里修改这几项即可，repo可以用博客的，后两项需要用到<code>GitHub Oauth App</code>的API，搜索引擎自行解决即可。</p><pre><code class="lang-yml">comment:    use: gitalk    gitalk_repo: # git repo of the hexo    gitalk_owner: # git repo&#39;s owner    gitalk_client_id:  # github app client id    gitalk_client_secret:  # github app client secret</code></pre><h3 id="GitHub限制label长度gitalk无法创建issue"><a href="#GitHub限制label长度gitalk无法创建issue" class="headerlink" title="GitHub限制label长度gitalk无法创建issue"></a>GitHub限制label长度gitalk无法创建issue</h3><blockquote><p><a href="https://github.com/viosey/hexo-theme-material/issues/622" target="_blank" rel="noopener">GitHub限制label长度导致gitment/gitalk可能无法创建issue #622</a></p></blockquote><p>对于全新安装有如下解决方案，解决方案如下：<br><code>hexo根目录\themes\material\layout\_widget\comment\gitalk</code><br>在此目录下编辑main.ejs文件<br>在其中新增如下内容</p><pre><code class="lang-html">&lt;script src=&quot;https://cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.js&quot;&gt;&lt;/script&gt;</code></pre><p>在gittalk下增加id属性，增加后完整文件内容如下：</p><pre><code class="lang-html">&lt;!-- Gitalk 评论框 --&gt;&lt;div id=&quot;gitalk-container&quot;&gt;&lt;/div&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;https://unpkg.com/gitalk/dist/gitalk.css&quot;&gt;&lt;script src=&quot;https://unpkg.com/gitalk/dist/gitalk.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;https://cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.js&quot;&gt;&lt;/script&gt;&lt;script&gt;    var gitalk = new Gitalk({            clientID: &#39;&lt;%= theme.comment.gitalk_client_id %&gt;&#39;,            clientSecret: &#39;&lt;%= theme.comment.gitalk_client_secret %&gt;&#39;,            repo: &#39;&lt;%= theme.comment.gitalk_repo %&gt;&#39;,            owner: &#39;&lt;%= theme.comment.gitalk_owner %&gt;&#39;,            admin: [&#39;&lt;%= theme.comment.gitalk_owner %&gt;&#39;],            id: md5(window.location.pathname),            // facebook-like distraction free mode            distractionFreeMode: false        })   gitalk.render(&#39;gitalk-container&#39;)&lt;/script&gt;</code></pre><h2 id="Blog内容搜索"><a href="#Blog内容搜索" class="headerlink" title="Blog内容搜索"></a>Blog内容搜索</h2><p>安装<code>hexo-generator-search</code>插件</p><p>修改主题配置文件</p><pre><code class="lang-yml">search:    use: local    swiftype_key:</code></pre><p>修改hexo配置文件：</p><pre><code class="lang-yml">search:    path: search.xml    field: all</code></pre><h2 id="markdown文件名大小写问题"><a href="#markdown文件名大小写问题" class="headerlink" title="markdown文件名大小写问题"></a>markdown文件名大小写问题</h2><p>参考：<a href="https://perphyyoung.github.io/2018/09/27/hexo-faq/" target="_blank" rel="noopener">Hexo 常见问题 | py’s blog</a></p><p>问题：<br>当在本地改变<code>md</code>文件的大小写时，部署到<code>GitHub</code> 上后，改变了文件名的博客不能被访问。<br>原因：<br><code>Hexo</code>默认的<code>git</code>操作会忽略大小写。<br>解决：</p><ol><li>修改根目录下<code>.deploy_git/.git/config</code>文件，将<code>ignorecase</code>的值由<code>true</code>改为<code>false</code></li><li>删除<code>.deploy_git</code>目录下除<code>.git</code>目录外的其他文件</li><li><code>cd</code>到<code>.deploy_git</code>目录下，手动做一次推送<pre><code class="lang-bash">git add .git commit -m &quot;delete all hexo generated files&quot;git push</code></pre></li><li>重新生成并部署<pre><code class="lang-bash">hexo ghexo d</code></pre></li></ol><h2 id="CSS的修改"><a href="#CSS的修改" class="headerlink" title="CSS的修改"></a>CSS的修改</h2><h3 id="文章框体透明"><a href="#文章框体透明" class="headerlink" title="文章框体透明"></a>文章框体透明</h3><p>打开<code>Blog\themes\hexo-theme-material-1.5.6\source\css</code>打开<code>style.min.css</code>搜索<code>#scheme-Paradox .material-layout .mdl-card</code>的第一项，在其中添加<code>background-color: rgba(255,255,255,0.8) !important;</code></p><h3 id="Tag颜色及悬停颜色"><a href="#Tag颜色及悬停颜色" class="headerlink" title="Tag颜色及悬停颜色"></a>Tag颜色及悬停颜色</h3><pre><code class="lang-css">.material-tagscloud a{        background-color: rgba(255,255,255,.9);        text-decoration:none;        padding: 1px 9px;        margin: 9px 1px;        line-height: 40px;        white-space: nowrap;        transition: .6s;        opacity: .85;    }</code></pre><pre><code class="lang-css">.material-tagscloud a:hover{        transition: .6s;        opacity: 1;        background: rgba(156,241,150,.7) !important;        box-shadow: 0 2px 2px 0 rgba(0,0,0,.14), 0 3px 1px -2px rgba(0,0,0,.2), 0 1px 5px 0 rgba(0,0,0,.12);    }</code></pre><h3 id="copyright位置"><a href="#copyright位置" class="headerlink" title="copyright位置"></a>copyright位置</h3><pre><code class="lang-css">#scheme-Paradox .mdl-mini-footer--right-section {    margin-right: 25px;}</code></pre><pre><code class="lang-css">#scheme-Paradox #copyright {    margin-left: auto;    margin-right: 25px;    text-align: center;}</code></pre><h2 id="MathJax"><a href="#MathJax" class="headerlink" title="MathJax"></a>MathJax</h2><p>主题配置文件中的<code>mathjax</code> 引用cdn<code>https://cdn.bootcss.com/mathjax/2.7.0/MathJax.js</code><br>$\LaTeX$换行因为某些网页渲染的原因把<code>\\</code>换为<code>\\\\</code>即可.</p><p>修改hexo的渲染规则可以避免LaTex代码出现问题：</p><p><a href="https://docs.nexmoe.com/hexo/math.html#%E4%BD%BF%E7%94%A8kramed%E4%BB%A3%E6%9B%BF-marked" target="_blank" rel="noopener">https://docs.nexmoe.com/hexo/math.html#%E4%BD%BF%E7%94%A8kramed%E4%BB%A3%E6%9B%BF-marked</a></p><p>MathJax测试</p><script type="math/tex; mode=display">\begin{array}{|rc|} \hline \verb+\color{black}{text}+ & \color{black}{text} \\ \verb+\color{gray}{text}+ & \color{gray}{text} \\ \verb+\color{silver}{text}+ & \color{silver}{text} \\ \verb+\color{white}{text}+ & \color{white}{text} \\ \hline \verb+\color{maroon}{text}+ & \color{maroon}{text} \\ \verb+\color{red}{text}+ & \color{red}{text} \\ \verb+\color{yellow}{text}+ & \color{yellow}{text} \\ \verb+\color{lime}{text}+ & \color{lime}{text} \\ \verb+\color{olive}{text}+ & \color{olive}{text} \\ \verb+\color{green}{text}+ & \color{green}{text} \\ \verb+\color{teal}{text}+ & \color{teal}{text} \\ \verb+\color{aqua}{text}+ & \color{aqua}{text} \\ \verb+\color{blue}{text}+ & \color{blue}{text} \\ \verb+\color{navy}{text}+ & \color{navy}{text} \\ \verb+\color{purple}{text}+ & \color{purple}{text} \\ \verb+\color{fuchsia}{text}+ & \color{magenta}{text} \\ \hline \end{array}</script><h2 id="自定义页脚sns链接"><a href="#自定义页脚sns链接" class="headerlink" title="自定义页脚sns链接"></a>自定义页脚sns链接</h2><blockquote><p><a href="https://story.wavky.com/2018/08/16/Hexo-Material%E4%B8%BB%E9%A2%98%E4%B9%8B-footer-SNS%E5%AE%9A%E5%88%B6/" target="_blank" rel="noopener">Hexo Material主题之 footer SNS定制</a></p></blockquote><p>svg图标如果在CSS里写实在还有问题放一个文件直接引用也可以.</p><p>sns换到右边把ejs文件里的<code>left</code>改为<code>right</code>即可.</p><h2 id="license"><a href="#license" class="headerlink" title="license"></a>license</h2><p>license: ‘本文由 Name 原创，采用<a href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh" target="_blank">保留署名-非商业性使用-禁止演绎 4.0-国际许可协议</a>‘</p><h2 id="鼠标点击烟花特效"><a href="#鼠标点击烟花特效" class="headerlink" title="鼠标点击烟花特效"></a>鼠标点击烟花特效</h2><p><code>themes/主体名称/source/js/src</code>新建<code>fireworks.js</code>文件</p><pre><code class="lang-js">&quot;use strict&quot;;function updateCoords(e){pointerX=(e.clientX||e.touches[0].clientX)-canvasEl.getBoundingClientRect().left,pointerY=e.clientY||e.touches[0].clientY-canvasEl.getBoundingClientRect().top}function setParticuleDirection(e){var t=anime.random(0,360)*Math.PI/180,a=anime.random(50,180),n=[-1,1][anime.random(0,1)]*a;return{x:e.x+n*Math.cos(t),y:e.y+n*Math.sin(t)}}function createParticule(e,t){var a={};return a.x=e,a.y=t,a.color=colors[anime.random(0,colors.length-1)],a.radius=anime.random(16,32),a.endPos=setParticuleDirection(a),a.draw=function(){ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.fillStyle=a.color,ctx.fill()},a}function createCircle(e,t){var a={};return a.x=e,a.y=t,a.color=&quot;#F00&quot;,a.radius=0.1,a.alpha=0.5,a.lineWidth=6,a.draw=function(){ctx.globalAlpha=a.alpha,ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.lineWidth=a.lineWidth,ctx.strokeStyle=a.color,ctx.stroke(),ctx.globalAlpha=1},a}function renderParticule(e){for(var t=0;t&lt;e.animatables.length;t++){e.animatables[t].target.draw()}}function animateParticules(e,t){for(var a=createCircle(e,t),n=[],i=0;i&lt;numberOfParticules;i++){n.push(createParticule(e,t))}anime.timeline().add({targets:n,x:function(e){return e.endPos.x},y:function(e){return e.endPos.y},radius:0.1,duration:anime.random(1200,1800),easing:&quot;easeOutExpo&quot;,update:renderParticule}).add({targets:a,radius:anime.random(80,160),lineWidth:0,alpha:{value:0,easing:&quot;linear&quot;,duration:anime.random(600,800)},duration:anime.random(1200,1800),easing:&quot;easeOutExpo&quot;,update:renderParticule,offset:0})}function debounce(e,t){var a;return function(){var n=this,i=arguments;clearTimeout(a),a=setTimeout(function(){e.apply(n,i)},t)}}var canvasEl=document.querySelector(&quot;.fireworks&quot;);if(canvasEl){var ctx=canvasEl.getContext(&quot;2d&quot;),numberOfParticules=30,pointerX=0,pointerY=0,tap=&quot;mousedown&quot;,colors=[&quot;#FF1461&quot;,&quot;#18FF92&quot;,&quot;#5A87FF&quot;,&quot;#FBF38C&quot;],setCanvasSize=debounce(function(){canvasEl.width=2*window.innerWidth,canvasEl.height=2*window.innerHeight,canvasEl.style.width=window.innerWidth+&quot;px&quot;,canvasEl.style.height=window.innerHeight+&quot;px&quot;,canvasEl.getContext(&quot;2d&quot;).scale(2,2)},500),render=anime({duration:1/0,update:function(){ctx.clearRect(0,0,canvasEl.width,canvasEl.height)}});document.addEventListener(tap,function(e){&quot;sidebar&quot;!==e.target.id&amp;&amp;&quot;toggle-sidebar&quot;!==e.target.id&amp;&amp;&quot;A&quot;!==e.target.nodeName&amp;&amp;&quot;IMG&quot;!==e.target.nodeName&amp;&amp;(render.play(),updateCoords(e),animateParticules(pointerX,pointerY))},!1),setCanvasSize(),window.addEventListener(&quot;resize&quot;,setCanvasSize,!1)}&quot;use strict&quot;;function updateCoords(e){pointerX=(e.clientX||e.touches[0].clientX)-canvasEl.getBoundingClientRect().left,pointerY=e.clientY||e.touches[0].clientY-canvasEl.getBoundingClientRect().top}function setParticuleDirection(e){var t=anime.random(0,360)*Math.PI/180,a=anime.random(50,180),n=[-1,1][anime.random(0,1)]*a;return{x:e.x+n*Math.cos(t),y:e.y+n*Math.sin(t)}}function createParticule(e,t){var a={};return a.x=e,a.y=t,a.color=colors[anime.random(0,colors.length-1)],a.radius=anime.random(16,32),a.endPos=setParticuleDirection(a),a.draw=function(){ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.fillStyle=a.color,ctx.fill()},a}function createCircle(e,t){var a={};return a.x=e,a.y=t,a.color=&quot;#F00&quot;,a.radius=0.1,a.alpha=0.5,a.lineWidth=6,a.draw=function(){ctx.globalAlpha=a.alpha,ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.lineWidth=a.lineWidth,ctx.strokeStyle=a.color,ctx.stroke(),ctx.globalAlpha=1},a}function renderParticule(e){for(var t=0;t&lt;e.animatables.length;t++){e.animatables[t].target.draw()}}function animateParticules(e,t){for(var a=createCircle(e,t),n=[],i=0;i&lt;numberOfParticules;i++){n.push(createParticule(e,t))}anime.timeline().add({targets:n,x:function(e){return e.endPos.x},y:function(e){return e.endPos.y},radius:0.1,duration:anime.random(1200,1800),easing:&quot;easeOutExpo&quot;,update:renderParticule}).add({targets:a,radius:anime.random(80,160),lineWidth:0,alpha:{value:0,easing:&quot;linear&quot;,duration:anime.random(600,800)},duration:anime.random(1200,1800),easing:&quot;easeOutExpo&quot;,update:renderParticule,offset:0})}function debounce(e,t){var a;return function(){var n=this,i=arguments;clearTimeout(a),a=setTimeout(function(){e.apply(n,i)},t)}}var canvasEl=document.querySelector(&quot;.fireworks&quot;);if(canvasEl){var ctx=canvasEl.getContext(&quot;2d&quot;),numberOfParticules=30,pointerX=0,pointerY=0,tap=&quot;mousedown&quot;,colors=[&quot;#FF1461&quot;,&quot;#18FF92&quot;,&quot;#5A87FF&quot;,&quot;#FBF38C&quot;],setCanvasSize=debounce(function(){canvasEl.width=2*window.innerWidth,canvasEl.height=2*window.innerHeight,canvasEl.style.width=window.innerWidth+&quot;px&quot;,canvasEl.style.height=window.innerHeight+&quot;px&quot;,canvasEl.getContext(&quot;2d&quot;).scale(2,2)},500),render=anime({duration:1/0,update:function(){ctx.clearRect(0,0,canvasEl.width,canvasEl.height)}});document.addEventListener(tap,function(e){&quot;sidebar&quot;!==e.target.id&amp;&amp;&quot;toggle-sidebar&quot;!==e.target.id&amp;&amp;&quot;A&quot;!==e.target.nodeName&amp;&amp;&quot;IMG&quot;!==e.target.nodeName&amp;&amp;(render.play(),updateCoords(e),animateParticules(pointerX,pointerY))},!1),setCanvasSize(),window.addEventListener(&quot;resize&quot;,setCanvasSize,!1)};</code></pre><p>在<code>themes/主体名称/layout/_layout.swig/ejs</code>的<code>&lt;/body&gt;</code>上方添加</p><pre><code class="lang-ejs">&lt;canvas class=&quot;fireworks&quot; style=&quot;position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;&quot; &gt;&lt;/canvas&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;//cdn.bootcss.com/animejs/2.2.0/anime.min.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;/js/src/fireworks.js&quot;&gt;&lt;/script&gt;</code></pre><h2 id="一些主题的小问题"><a href="#一些主题的小问题" class="headerlink" title="一些主题的小问题"></a>一些主题的小问题</h2><p>独立页面<code>toc</code>不是默认为<code>true</code>的，需要手动开</p><pre><code>toc: true</code></pre><p>独立页面的<code>license</code>会在最后加上<code>index.html</code>，点击这个链接会导致<code>gitalk</code>再次创建<code>issue</code>，目前没有去解决.</p><h1 id="天坑"><a href="#天坑" class="headerlink" title="天坑"></a>天坑</h1><p>咕了很久全忘了，觉得以后再修blog就凉了，有空就填。</p><h2 id="修改后没记录"><a href="#修改后没记录" class="headerlink" title="修改后没记录"></a>修改后没记录</h2><p>代码高亮</p><p>功能页面 | 独立页面</p><p>material图标</p><h2 id="想添加的功能"><a href="#想添加的功能" class="headerlink" title="想添加的功能"></a>想添加的功能</h2><p><strong>aplayer</strong></p><p><strong>jsdelivr</strong></p><p>插入pdf</p><p>rss订阅</p><p>代码复制功能</p><p>鼠标特效fireworks遮挡</p><p>文章头图自定义</p><p>js时间统计，页脚动态效果</p><p>hexo-addlink</p><p>文章置顶</p><p>字体，代码字体</p><p>背景js动态效果</p><p>文章头图</p><p>Site Information</p><p>npm install hexo-math —save</p><h1 id="Git指令"><a href="#Git指令" class="headerlink" title="Git指令"></a>Git指令</h1><h2 id="常用指令"><a href="#常用指令" class="headerlink" title="常用指令"></a>常用指令</h2><p>克隆</p><pre><code class="lang-bash">git clone repo</code></pre><p>克隆分支</p><pre><code class="lang-bash">git clone -b branch_name repo</code></pre><hr><p>上传文件</p><pre><code class="lang-bash">git add .git commit -m &#39;update_name&#39;git push origin branch_name</code></pre><hr><p>Hexo指令</p><pre><code class="lang-bash">hexo inithexo clean g dhexo shexo new name categories</code></pre><h2 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h2><p><a href="https://zdran.com/20180326.html" target="_blank" rel="noopener">https://zdran.com/20180326.html</a></p><p>创建源文件git目录</p><pre><code class="lang-bash">git initgit remote add origin https://github.com/xx/xx.github.io // 填入你的repo地址</code></pre><p>创建分支</p><pre><code class="lang-bash">git checkout -b branch_namegit add .git commit -m &#39;add branch_name&#39;git push origin branch_name</code></pre><p>切换分支</p><pre><code class="lang-bash">git checkout branch_name</code></pre>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Blog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「FFT/NTT」「多项式」</title>
      <link href="/2019/FFT/"/>
      <url>/2019/FFT/</url>
      
        <content type="html"><![CDATA[<p>Update on A.D.2019-08-15</p><p>必忘原理的<code>FFT</code></p><a id="more"></a><iframe src="//player.bilibili.com/player.html?aid=19141078&cid=31220967&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="false" width="360px" height="560px"> </iframe><p>测试一下视频，然而貌似只有<code>bilibili</code>的外链比较好<span class="heimu" title="你知道的太多了">总不能放Youtube？</span>，然而鬼畜的二维码与顶部链接比前几年在<code>mcbbs</code>看的时候烂多了。</p><hr><p>在<code>2019年8月15日</code>，终于看懂了<code>FFT</code>的推导过程。</p><p>首先是<code>FFT</code>的板子，这个写法其实很优美<span class="heimu" title="你知道的太多了">记不住的</span>。</p><pre><code class="lang-c++">#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;complex&gt;#define R registerusing namespace std;const int N = 4.2e6;const double PI = acos(-1);int n, r[N];class C {public:    double r, i;    C() { r = i = 0; }    C(R double x, R double y) { r = x; i = y; }    C operator + (R C&amp; x) { return C(r+x.r, i+x.i); }    C operator - (R C&amp; x) { return C(r-x.r, i-x.i); }    C operator * (R C&amp; x) { return C(r*x.r-i*x.i, r*x.i+i*x.r); }    void operator += (R C&amp; x) { r += x.r; i += x.i; }    void operator *= (R C&amp; x) { R double t = r; r = r*x.r-i*x.i; i = t*x.i+i*x.r; }}f[N], g[N];inline void FFT(R C *a, R int op){    R C W, w, t, *a0, *a1;    R int i, j, k;    for (i = 0; i &lt; n; ++i)        if (i &lt; r[i]) t = a[i], a[i] = a[r[i]], a[r[i]] = t;    for(i = 1; i &lt; n; i &lt;&lt;= 1)        for(W = C(cos(PI/i), sin(PI/i) * op), j = 0; j &lt; n; j += i &lt;&lt; 1)            for(w = C(1, 0), a1 = i + (a0 = a + j), k = 0; k &lt; i; ++k, ++a0, ++a1, w*=W)                t = *a1 * w, *a1 = *a0 - t, *a0 += t;}int main(){    R int m, i, l = 0;    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);    for(i = 0; i &lt;= n; i++) scanf(&quot;%lf&quot;, &amp;f[i].r);    for(i = 0; i &lt;= m; i++) scanf(&quot;%lf&quot;, &amp;g[i].r);    for(m += n, n = 1; n &lt;= m; n &lt;&lt;= 1, ++l);    for(i = 0; i &lt; n; ++i) r[i] = (r[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (l - 1));    FFT(f, 1); FFT(g, 1);    for(i = 0; i &lt; n; ++i) f[i] *= g[i];    FFT(f, -1);    for(i = 0; i &lt;= m; ++i) printf(&quot;%.0lf &quot;, fabs(f[i].r) / n);    return 0;}</code></pre><p>咕，马上补.</p>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FFT </tag>
            
            <tag> NTT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「动态规划」</title>
      <link href="/2019/dp/"/>
      <url>/2019/dp/</url>
      
        <content type="html"><![CDATA[<p>Update on A.D.2019-08-2x</p><p>推不出的<code>DP</code>方程</p><a id="more"></a><p>随意记点动态规划的方程，大概是NOIP难度的。</p><h1 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h1><h2 id="水题"><a href="#水题" class="headerlink" title="水题"></a>水题</h2><h3 id="Luogu-P1472-奶牛家谱-Cow-Pedigrees"><a href="#Luogu-P1472-奶牛家谱-Cow-Pedigrees" class="headerlink" title="Luogu P1472 奶牛家谱 Cow Pedigrees"></a>Luogu P1472 奶牛家谱 Cow Pedigrees</h3><p>题意：有$n$个结点$k$层的二叉树结构个数，树只能有$2$个儿子或$0$个儿子。</p><p>设$dp[n][k]$为有$n$个结点不到$k$层的答案，则答案容斥一下为$dp[n][k]-dp[n][k-1]$，转移从下把两棵树连接到上一层结点，枚举$t$为左子树节点个数，则右子树为$总结点个数-t-1$(1是减掉根)，乘法原理把两个乘起来，方程为</p><script type="math/tex; mode=display">dp[i][j]=\sum dp[t][j-1]\times dp[i-t-1][j-1]</script><h2 id="正常题"><a href="#正常题" class="headerlink" title="正常题"></a>正常题</h2><h3 id="Luogu-P2495-SDOI2011-消耗战"><a href="#Luogu-P2495-SDOI2011-消耗战" class="headerlink" title="Luogu P2495 [SDOI2011]消耗战"></a>Luogu P2495 [SDOI2011]消耗战</h3><p>题意：给定$n$个点有边权的树，割断边花费边权，求使$k$个点与$1$点不连通的最小花费。</p><p>要用虚树做，写一下方程。</p><p>设$dp[n]$为使以$n$为结点的子树内关键点都不与$n$联通的最小花费，方程为</p><script type="math/tex; mode=display">dp[u]=dp[u]+\begin{cases}\min(dp[v],dist_{u,v})& \text{v不是关键点}\\dist_{u,v}& \text{v是关键点}\end{cases}</script><h3 id="Luogu-P2606-ZJOI2010-排列计数"><a href="#Luogu-P2606-ZJOI2010-排列计数" class="headerlink" title="Luogu P2606 [ZJOI2010]排列计数"></a>Luogu P2606 [ZJOI2010]排列计数</h3><p>题意：求一个$1\sim n$的排列$P_i$使$ 1\leq  i \leq n$时$P_i&gt;P_{i/2}$的方案数。</p><p>直接做没什么思路，可以想一下除二的关系可以是二叉树，于是换到树上来做，求$n$个节点的二叉树满足小根堆性质树的个数。</p><p>设$dp[i]$表示以$i$为根的子树内满足小根堆性质的方案数，$s[i]$为树结点数，提前把一些越界的初值设为$1$以免判断，转移时组合数算一下选给左子树的点，记得减去根节点，乘一下两颗子树的方案数就ok了，组合数要用lucas，方程</p><script type="math/tex; mode=display">dp[i]=C_{s[i]-1}^{s[i\times 2]}dp[i\times 2]dp[i\times 2+1]</script><h3 id="Luogu-P2473-SCOI2008-奖励关"><a href="#Luogu-P2473-SCOI2008-奖励关" class="headerlink" title="Luogu P2473 [SCOI2008]奖励关"></a>Luogu P2473 [SCOI2008]奖励关</h3><p>题意：$m$种物品，给你n次随机在$1\sim m$间的物品，每种物品有价值并且选这种物品需要你在前$n-1$次把集合$S$内的物品种类都选过一次才可以选。</p><p>显然$m$非常小，那么求期望直接枚举就可以了，这样就好做了，然后在考虑一下如果顺推的话需要保证$S$的合法性，这个比较难处理，那么逆推显然更好写。设$dp[i][S]$表示取前$i-1$次的状态为$S$是期望的最大值，$pre[i]$为第$i$种物品的前提集合，方程枚举第i个选第k种</p><script type="math/tex; mode=display">dp[i][S]=dp[i][S]+\begin{cases}\max(dp[i+1][S],dp[i+1][S|(1<<(k-1))]+val[k])& pre[i]\subseteq S \\dp[i+1][S]& pre[i]\nsubseteq  S\end{cases}</script><p>每次$dp[i][S]​$转移完之后变成$\dfrac{dp[i][S]}{n}​$来求期望，答案是$dp[1][0]​$.</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从零开始的C++学习</title>
      <link href="/2019/C++/"/>
      <url>/2019/C++/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Update on A.D.2019-08-xx</p></blockquote><p><code>Visual Studio</code>过于复杂</p><a id="more"></a><p>装了一下之前很久以前装过一次却没用过的Visual Studio，打算随便学一下C++的OOP还有一些C++11的语法？然后学下C++的图形界面的库，然后随便玩玩？那大概就是这样吧。随便记点不好记的语法方便查一下然后记一下现在还不大会用的vs的操作方便以后忘了再查。</p><p>参考<a href="https://www.runoob.com/cplusplus" target="_blank" rel="noopener">C++ 教程 | 菜鸟教程</a>先看一遍然后记点容易忘的。</p><p>其实还有一本<code>C++ Primer Plus</code>不过现在大概是没时间看了</p><h1 id="C-OOP"><a href="#C-OOP" class="headerlink" title="C++ OOP"></a>C++ OOP</h1><h2 id="类-对象"><a href="#类-对象" class="headerlink" title="类 对象"></a>类 对象</h2><p><code>class Hf{...};</code>定义一个类</p><p><code>Hf xxx;</code>声明一个类型为<code>Hf</code>的对象</p><p>访问数据成员用<code>.</code>即可</p><h3 id="成员函数"><a href="#成员函数" class="headerlink" title="成员函数"></a>成员函数</h3><p>类定义内部的成员函数默认<code>inline</code></p><p>在类的外部定义函数的话用范围解析运算符<code>::</code>定义成员函数</p><pre><code class="lang-c++">数据类型 类名::函数名() {}</code></pre><p>调用函数用<code>.</code> 即可</p><h3 id="类访问修饰符"><a href="#类访问修饰符" class="headerlink" title="类访问修饰符"></a>类访问修饰符</h3><p><code>public</code>公有成员在程序中类的外部是可访问的。您可以不使用任何成员函数来设置和获取公有变量的值</p><p><code>private</code><strong>私有</strong>成员变量或函数在类的外部是不可访问的，甚至是不可查看的。只有类和友元函数可以访问私有成员。</p><p><code>protected</code><strong>保护</strong>成员变量或函数与私有成员十分相似，但有一点不同，保护成员在派生类（即子类）中是可访问的。</p><hr><p>1.<strong>public 继承：</strong>基类 public 成员，protected 成员，private 成员的访问属性在派生类中分别变成：public, protected, private</p><p>2.<strong>protected 继承：</strong>基类 public 成员，protected 成员，private 成员的访问属性在派生类中分别变成：protected, protected, private</p><p>3.<strong>private 继承：</strong>基类 public 成员，protected 成员，private 成员的访问属性在派生类中分别变成：private, private, private</p><hr><p>1.private 成员只能被本类成员（类内）和友元访问，不能被派生类访问；</p><p>2.protected 成员可以被派生类访问。</p><h3 id="类构造函数-amp-析构函数"><a href="#类构造函数-amp-析构函数" class="headerlink" title="类构造函数 &amp; 析构函数"></a>类构造函数 &amp; 析构函数</h3><p>构造函数就定义一个函数名为类名没有数据类型的函数，每次创建类的新对象时执行，默认是存在构造函数，所以如果定义了有参数的构造函数，一定注意要再定义一个无参数无内容的构造函数，不然不用带参数的构造函数用默认创建对象的话会出错.<br>像这样玩就行，赋值可以像这样搞.</p><pre><code class="lang-c++">struct node {    int o, l, r, t;    node() {}    node(int o, int l, int r): o(o), l(l), r(r), t(ask(l, r)) {}    friend bool operator &lt; (const node&amp; a, const node&amp; b) {        return sum[a.t] - sum[a.o - 1] &lt; sum[b.t] - sum[b.o - 1];    }};</code></pre><p>析构函数名字是这样的<code>~类名</code>，这个函数再删除对象时执行.<br>总之就是一个创建，一个删除时执行。</p><hr><p>前面的随便看了看就咕了不记东西了，<code>OOP</code>还有很多东西不会也没写过。</p><p>先写写<code>mfc</code>，感觉挺好玩的，得先看看常用的函数然后写点简单东西练一练。</p><p>然后想看点C++11的特性，学一下<code>auto</code>，新语法之类的，现在不是很了解。</p><p>还有想学C++网络方面的内容，以及学一下套接字、这样的网络知识和服务器相关的内容。</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「数论」</title>
      <link href="/2019/number_theory/"/>
      <url>/2019/number_theory/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Update on A.D.2019-08-xx</p></blockquote><p>只会<code>GCD</code></p><a id="more"></a><h1 id="取模"><a href="#取模" class="headerlink" title="取模"></a>取模</h1><script type="math/tex; mode=display">(a+b) \bmod p=(a\bmod p+b\bmod p)\bmod p​</script><script type="math/tex; mode=display">(a-b) \bmod p=(a\bmod p-b\bmod p+p)\bmod p​</script><script type="math/tex; mode=display">(a\times b) \bmod p=(a\bmod p\times b\bmod p)\bmod p​</script><p>求$\dfrac{a}{b}\bmod p​$时,求$b^{-1}​$使$b*b^{-1}\equiv1\pmod p​$即$b​$的逆元</p><p>有<script type="math/tex">\dfrac{a}{b}\bmod p=a\times b^{-1}\bmod p</script></p><h1 id="费马小定理"><a href="#费马小定理" class="headerlink" title="费马小定理"></a>费马小定理</h1><p>定理：当$p​$是质数时$a^{p-1}\equiv 1\pmod p​$</p><p>逆元：由$a^{p-1}\equiv 1\pmod p​$得$a\times a^{p-2}\equiv 1\pmod p​$</p><p>即$a^{p-1}$是$a$在模$p$意义下的逆元</p><h1 id="欧拉定理"><a href="#欧拉定理" class="headerlink" title="欧拉定理"></a>欧拉定理</h1><p>若$gcd(a,p)=1$则$a^{\varphi(p)}\equiv1\pmod n$</p><p>当$p$是质数时$\varphi(p)=p-1$</p><p>即$a^{p-1}\equiv1\pmod n$即费马小定理</p><h1 id="GCD-EXGCD"><a href="#GCD-EXGCD" class="headerlink" title="GCD EXGCD"></a>GCD EXGCD</h1><pre><code class="lang-c++">#define ll long longll gcd(ll a, ll b) { return b ? gcd(b, a%b) : a; }void exgcd(ll a, ll b, ll &amp;x, ll &amp;y) {    if(!b) x = 1, y = 0;    else exgcd(b, a % b, y, x), y -= a / b * x;}</code></pre><p>$gcd$用来求解$a，b$的最大公约数</p><p>$lcm(a,b)=\dfrac{a\times b}{gcd(a,b)}​$，lcm是最大公约数</p><p>$exgcd$用来求解$ax+by=gcd(a,b)$，证明大概是化式子构造递归的解法，反正看了也早晚会忘就是了<del>逃</del></p><p>$exgcd$还可以求解$ax\equiv b\pmod p​$形式的同余方程</p><p>$exgcd(a,p,x,y)$求出来的$x$就是$a$关于$p$的逆元</p><h1 id="CRT-exCRT"><a href="#CRT-exCRT" class="headerlink" title="CRT exCRT"></a>CRT exCRT</h1><p>求解一个同余方程组</p><script type="math/tex; mode=display">\begin{cases}x \equiv a_1 \pmod {m_1} \\x \equiv a_2 \pmod {m_2} \\x \equiv a_n \pmod {m_n}\end{cases}</script><p>两种东西都可以通过exgcd两两合并同余方程求解，不过CRT可以直接构造出答案。</p><p>CRT求解的$p​$是质数，exCRT的不是，都可以用exgcd合并做。</p><p>推导参考这个blog：<a href="http://blog.miskcoo.com/2014/09/chinese-remainder-theorem" target="_blank" rel="noopener">扩展欧几里得算法与中国剩余定理</a></p><p>CRT直接构造的解：</p><p>令$M=\prod m_i, M_i=\frac M{m_i}​$，$t_i​$为$M_i​$在模$m_i​$意义下的逆元</p><p>方程组的解为<script type="math/tex">x \equiv \sum_{i=1}^na_it_iM_i \pmod M​</script></p><h1 id="筛法"><a href="#筛法" class="headerlink" title="筛法"></a>筛法</h1><p>求$n$是不是素数直接枚举$1$到$\sqrt{n}$试除</p><p>埃筛</p><pre><code class="lang-c++">for(int i = 2; i &lt;= N; i++) if(!vis[i]) {    prime[++cnt] = i;    for(int j = 1; i * j &lt;= N; j++)           vis[i * j] = 1;}</code></pre><p>线筛</p><pre><code class="lang-c++">for(int i = 2; i &lt;= N; i++) {    if(!vis[i]) prime[++cnt] = i;    for(int j = 1; j &lt;= cnt &amp;&amp; i * prime[j] &lt;= N; j++) {        vis[i * prime[j]] = 1;        if(i % prime[j] == 0) break;    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Chrome浏览器 | 插件与设置</title>
      <link href="/2019/chrome/"/>
      <url>/2019/chrome/</url>
      
        <content type="html"><![CDATA[<p>Update on A.D.2019-06-04</p><p>好玩的<code>Chrome</code></p><a id="more"></a><h1 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h1><p>下载地址：<a href="https://www.google.cn/intl/zh-CN/chrome" target="_blank" rel="noopener">Google Chrome 网络浏览器</a></p><h1 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h1><p><code>Bookmarkie</code> 插件栏弹出收藏夹，可搜索</p><p><code>书签侧边栏</code> 侧边栏收藏夹</p><p><code>Wrona History Menu</code> 插件栏弹出历史记录，最近关闭</p><p><code>Checker Plus for Gmail™</code> 查看Google邮箱</p><p><code>Click and Save</code> 快捷键点击存图</p><p><code>CSS Peeper</code> 抓取页面样式</p><p><code>Earth View from Google Earth</code> 新页标签Google地球</p><p><code>Color Tab</code> 新页标签配色设计</p><p><code>Save All Resources</code> 下载控制台<code>Sources</code>全部文件</p><p><code>Steam Inventory Helper</code> steam网页版市场工具</p><p><code>Speedtest by Ookla</code> 墙外测速</p><p><code>Stylus</code> 替换CSS样式</p><p><code>Tampermonkey</code> 网页js脚本</p><p><code>Yet another flags</code> 查看网页ip</p><p><code>沙拉查词</code> 划词翻译</p><p><code>ImageAssistant</code> 下载网页图片</p><p><code>Yet Another Drag and Go</code> 四方向拖拽搜索，链接拖拽打开</p><p><code>pakku</code> bilibili弹幕过滤</p><p><code>Aerys</code> 插件栏查看窗口标签</p><h1 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h1><p><code>左键单击</code> = 在当前窗口打开目标网页</p><p><code>Shift + 左键单击</code> = 在新窗口打开目标网页</p><p><code>Ctrl + 左键单击</code> = 在新标签页打开目标网页</p><hr><p><code>Ctrl + Shift + T</code> = 打开上一个关闭的标签页</p><p><code>Ctrl + Shift + B</code> = 显示书签栏</p><p><code>Ctrl + D</code> = 为此页添加书签</p><p><code>Ctrl + H</code> = 历史记录</p><h1 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h1><p>不在设置里出现的控制选项： chrome://flags</p><p>查看chrome账号同步情况： chrome://sync</p><hr><p>地址栏中使用的搜索引擎改为<code>google.com.hk</code></p><h1 id="网页长截图"><a href="#网页长截图" class="headerlink" title="网页长截图"></a>网页长截图</h1><p>1.按<code>F12</code></p><p>2.按<code>Ctrl + Shift + P</code></p><p>3.输入<code>Capture full size screenshot</code>并回车</p><h2 id="截取手机版长图"><a href="#截取手机版长图" class="headerlink" title="截取手机版长图"></a>截取手机版长图</h2><p>在1、2操作之间，按下<code>Ctrl + Shift + M</code></p><h2 id="选区截图"><a href="#选区截图" class="headerlink" title="选区截图"></a>选区截图</h2><p>1.按<code>F12</code></p><p>2.按<code>Ctrl + Shift + C</code></p><p>3.选中区域后去输入<code>Capture node screenshot</code>并回车</p>]]></content>
      
      
      <categories>
          
          <category> PC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> chrome </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>科学上网 | GFW与SSR简介</title>
      <link href="/2019/GFW/"/>
      <url>/2019/GFW/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Update on A.D.2019-05-31</p></blockquote><p>Across the Great Wall we can reach every corner in the world.</p><a id="more"></a><p>由于一些政治原因，中国的网络环境非常特殊，不仅自身进行审查，且对外来信息也会进行审查，如果需要访问境外网站，使用一些境外服务及app则需要突破审查，俗称翻墙，科学上外，搭梯子等。在10010大进行了今年来最为严厉的网络审查，在此之后一些免费的fq软件都不甚理想。<br>本文介绍GFW和常用的翻墙技术，以作备忘和对没有接触过fq的人作简单的了解。</p><p>推荐阅读：<br><a href="https://blog.nfz.moe/archives/network-in-china.html" target="_blank" rel="noopener">中国的互联网 _ neoFelhz’s Blog</a></p><p><a href="https://hynking.org/2017/01/02/The_reason/" target="_blank" rel="noopener">墙与纸飞机</a></p><h1 id="什么是GFW？"><a href="#什么是GFW？" class="headerlink" title="什么是GFW？"></a>什么是GFW？</h1><h2 id="出海光缆"><a href="#出海光缆" class="headerlink" title="出海光缆"></a>出海光缆</h2><p>中国接入$Internet$的情况：<br><a href="https://www.ruanyifeng.com/blog/2010/08/cable_world_map.html" target="_blank" rel="noopener">世界海底光缆分布图 - 阮一峰的网络日志</a></p><p>中国出海光缆有$3$条，分别在青岛、汕头、上海，那么对为数不多的出海光缆控制一下、进行一下审查，便可以达到信息封锁的目的，这个技术的缩写叫做$GFW$，经常被称为墙，曾经由某$Hf$亲自主持建设。</p><h2 id="GFW"><a href="#GFW" class="headerlink" title="GFW"></a>GFW</h2><p><a href="https://zh.wikipedia.org/wiki/%E9%98%B2%E7%81%AB%E9%95%BF%E5%9F%8E" target="_blank" rel="noopener">防火长城 - 维基百科，自由的百科全书</a></p><p>部分内容</p><pre><code>现阶段防火长城已经具备干扰IPv6隧道的能力。2013年对代码托管网站GitHub的审查和封锁2013年1月20日，中国大陆政府的防火长城利用域名污染和关键词过滤等手段屏蔽GitHub。但是，由于屏蔽引发了社会的强烈反应，最终解除了对GitHub的屏蔽。Steam社区网站被屏蔽Steam是世界最大的PC数字游戏平台，其社区网站被用于讨论和分享游戏经验。Steam在中国也有着庞大的用户群，根据Steam Spy2017年底的报告，Steam的中国区玩家已经突破3000万，其不受中国监管的社群被认为带来了监管方面的挑战。Steam自2015年开启人民币结算以来，曾多次因部分网民在社区发表违反中国法律的内容而遭到屏蔽，在Valve配合删除相关违规言论并封禁违规用户后均解除了屏蔽。但自2017年12月16日起，Steam除了商店，其他功能（社区、市场、库存、创意工坊）均被屏蔽，方法是DNS污染和SNI RST，该屏蔽至今仍未解除，玩家需要使用加速器或在修改hosts的同时使用本地反向代理等工具才能访问，但中国大陆部分地区的用户即使是使用了加速器或本地反向代理，在访问社区的时候仍然会提示“您所在的地区不支持”，原因未知。</code></pre><p>技术</p><pre><code>主要技术2.1    域名解析服务缓存污染2.2    IP地址或传输层端口封锁2.2.1    针对TCP和UDP连接的封锁2.2.2    针对UDP连接的干扰2.3    TCP连接重置2.3.1    针对HTTP协议的关键字阻断2.3.2    针对TLS的SNI阻断2.3.3    针对TLS的证书传输检测2.3.4    对eD2k协议的连接干扰2.4    其他2.4.1    对破网软件的反制2.4.1.1    针对Tor的刺探2.4.2    间歇性完全封锁2.4.2.1    间歇性封锁国际出口2.4.2.2    境内骨干路由器间歇性阻断2.4.3    深度包检测2.4.4    针对IPv6协议的审查2.4.5    对电子邮件通讯的拦截2.4.6    网络攻击</code></pre><p>硬件</p><pre><code>据2010年的估计，防火长城可能拥有数百台曙光4000L服务器。防火长城（北京）使用曙光4000L机群，操作系统为Red Hat系列（从7.2到7.3到AS4），周边软件见曙光4000L一般配置防火长城实验室（哈尔滨工业大学）使用曙光服务器，Red Hat操作系统防火长城（上海）使用Beowulf集群。GFW是曙光4000L的主要需求来源、研究发起者、客户、股东、共同开发者。2007年防火长城集群规模进一步扩大，北京增至360节点，上海增至128节点，哈尔滨增至64节点，共计552节点。机群间星型千兆互联。计划节点数上千。有多方证据表明防火长城（广州）存在，但其使用的服务器和系统不确定。有理由相信防火长城（北京）拥有16套曙光4000L，每套384节点，其中24个服务和数据库节点，360个计算节点。每套价格约两千万到三千万，占005工程经费的主要部分。有3套（将）用于虚拟计算环境实验床，计千余节点。13套用于骨干网络过滤。总计6144节点，12288CPU，12288GB内存，峰值计算速度48万亿次。2 GHz CPU的主机Linux操作系统下可达到600Kbps以上的捕包率。通过骨干网实验，配置16个数据流总线即可以线速处理八路OC48（一路OC48约2.5Gbps）接口网络数据。曙光4000L单结点的接入能力为每秒65万数据包，整个系统能够满足32Gbps的实时数据流的并发接入要求。有理由相信GFW的总吞吐量为512Gbps甚至更高（北京）。</code></pre><p>典型意义下GFW的线路拓扑：</p><p><img src="/images/gfw.png" alt></p><hr><p><a href="https://zh.wikipedia.org/wiki/%E4%B8%AD%E5%8D%8E%E4%BA%BA%E6%B0%91%E5%85%B1%E5%92%8C%E5%9B%BD%E8%A2%AB%E5%B0%81%E9%94%81%E7%BD%91%E7%AB%99%E5%88%97%E8%A1%A8" target="_blank" rel="noopener">中华人民共和国被封锁网站列表 - 维基百科，自由的百科全书</a></p><p><a href="https://zh.wikipedia.org/wiki/%E4%B8%AD%E5%8D%8E%E4%BA%BA%E6%B0%91%E5%85%B1%E5%92%8C%E5%9B%BD%E7%BD%91%E7%BB%9C%E5%AE%A1%E6%9F%A5" target="_blank" rel="noopener">中华人民共和国网络审查 - 维基百科，自由的百科全书</a></p><p>其他：<br>面对 HTTPS 加密，GFW 的敏感词过滤失效。</p><h2 id="其他名词"><a href="#其他名词" class="headerlink" title="其他名词"></a>其他名词</h2><p>VPS：虚拟专用服务器（英语：Virtual private server，缩写为 VPS）<br><a href="https://zh.wikipedia.org/wiki/%E8%99%9A%E6%8B%9F%E4%B8%93%E7%94%A8%E6%9C%8D%E5%8A%A1%E5%99%A8" target="_blank" rel="noopener">虚拟专用服务器 - 维基百科，自由的百科全书</a></p><p>代理（英语：Proxy）也称网络代理，是一种特殊的网络服务，允许一个网络终端（一般为客户端）通过这个服务与另一个网络终端（一般为服务器）进行非直接的连接。<br>提供代理服务的计算机系统或其它类型的网络终端称为代理服务器（英文：Proxy Server）。<br><a href="https://zh.wikipedia.org/wiki/%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8" target="_blank" rel="noopener">代理服务器 - 维基百科，自由的百科全书</a></p><p>SOCKS是一种网络传输协议，主要用于客户端与外网服务器之间通讯的中间传递。SOCKS是”SOCKetS”的缩写。<br><a href="https://zh.wikipedia.org/wiki/SOCKS" target="_blank" rel="noopener">SOCKS - 维基百科，自由的百科全书</a></p><p>网际协议第6版（英语：Internet Protocol version 6，缩写：IPv6）是网际协议的最新版本，用作互联网的网络层协议。用它来取代IPv4主要是为了解决IPv4地址枯竭问题，同时它也在其他方面对于IPv4有许多改进。<br><a href="https://zh.wikipedia.org/wiki/IPv6" target="_blank" rel="noopener">IPv6 - 维基百科，自由的百科全书</a></p><p>Secure Shell（安全外壳协议，简称SSH）是一种加密的网络传输协议，可在不安全的网络中为网络服务提供安全的传输环境。SSH通过在网络中创建安全隧道来实现SSH客户端与服务器之间的连接。<br><a href="https://zh.wikipedia.org/wiki/Secure_Shell" target="_blank" rel="noopener">Secure Shell - 维基百科，自由的百科全书</a></p><p>超文本传输安全协议（英语：HyperText Transfer Protocol Secure，缩写：HTTPS；常称为HTTP over TLS、HTTP over SSL或HTTP Secure）是一种通过计算机网络进行安全通信的传输协议。HTTPS经由HTTP进行通信，但利用SSL/TLS来加密数据包。HTTPS开发的主要目的，是提供对网站服务器的身份认证，保护交换数据的隐私与完整性。<br><a href="https://zh.wikipedia.org/wiki/%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE" target="_blank" rel="noopener">超文本传输安全协议 - 维基百科，自由的百科全书</a></p><p>对等式网络（peer-to-peer， 简称P2P），又称点对点技术，是无中心服务器、依靠用户群（peers）交换信息的互联网体系，它的作用在于，减低以往网路传输中的节点，以降低资料遗失的风险。与有中心服务器的中央网络系统不同，对等网络的每个用户端既是一个节点，也有服务器的功能，任何一个节点无法直接找到其他节点，必须依靠其户群进行信息交流。<br><a href="https://zh.wikipedia.org/wiki/%E5%B0%8D%E7%AD%89%E7%B6%B2%E8%B7%AF" target="_blank" rel="noopener">点对点网络 - 维基百科，自由的百科全书</a></p><p>HTTP状态码（英语：HTTP Status Code）是用以表示网页服务器超文本传输协议响应状态的3位数字代码。<br><a href="https://zh.wikipedia.org/wiki/HTTP%E7%8A%B6%E6%80%81%E7%A0%81" target="_blank" rel="noopener">HTTP状态码 - 维基百科，自由的百科全书</a></p><p>中间人攻击（英语：Man-in-the-middle attack，缩写：MITM）在密码学和计算机安全领域中是指攻击者与通讯的两端分别创建独立的联系，并交换其所收到的数据，使通讯的两端认为他们正在通过一个私密的连接与对方直接对话，但事实上整个会话都被攻击者完全控制。在中间人攻击中，攻击者可以拦截通讯双方的通话并插入新的内容。<br><a href="https://zh.wikipedia.org/wiki/%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB" target="_blank" rel="noopener">中间人攻击 - 维基百科，自由的百科全书</a></p><h1 id="如何科学上网"><a href="#如何科学上网" class="headerlink" title="如何科学上网"></a>如何科学上网</h1><p><a href="https://zh.wikipedia.org/wiki/%E7%AA%81%E7%A0%B4%E7%BD%91%E7%BB%9C%E5%AE%A1%E6%9F%A5" target="_blank" rel="noopener">突破网络审查 - 维基百科，自由的百科全书</a><br>作为修改hosts文件这一常用手段，目前基本已经失效：<br><a href="https://zh.wikipedia.org/wiki/Hosts%E6%96%87%E4%BB%B6" target="_blank" rel="noopener">hosts文件 - 维基百科，自由的百科全书</a></p><pre><code>修改本机 hosts文件，不足之处是需要系统管理员权限（如root权限）来修改，对基于IP地址封禁的网站无效。自2018年8月份起，GFW开始启用基于SNI检测和TCP连接重置的手段进行封锁，所以修改hosts方法不再完全适用。</code></pre><p>一些相关软件的介绍</p><pre><code>相关软件蓝灯（Lantern），免费（3.x以后有付费版本，免费版4.x以后版本为每月500M，超出限速）、开源，支持多平台（Windows、Linux、Android）。蓝灯能够自动检测一个网站是否被封锁。对那些被封锁的网站，Lantern 通过自有的服务器或者未封锁地区的用户运行的 Lantern 来提供访问。赛风，免费、开源，支持多平台（Windows、Android、iOS），但链接不稳定萤火虫（Firefly），用 Go 语言编写，采取 meek 工作原理，支持多平台（Windows、Android、iOS）XXNET浏览器集成包，为进一步降低破网难度，有志愿者将Chromium、Firefox等浏览器，与已经配置好的翻墙软件（如GoAgent和Shadowsocks的客户端软件）一起打包成一键翻墙的浏览器集成包。这类浏览器集成包并不能提供高度安全的隐私保护，因为浏览器集成包的制作者可能会在制作过程中加入恶意程序。当然，这类浏览器集成包的确易于使用。洋葱路由器（Tor），同时提供暗网及代理。大蒜路由器（I2P），Tor的演进版本，基于Java技术，使用 ed2k 技术实现分布式网络避免全网封杀。代理服务器此类软件需要自行在服务器和终端上部署，比一般的翻墙方法更繁琐。Shadowsocks，简称SS，需要自行购买VPS并搭建代理服务器，用于翻墙，在坊间也有可以直接使用的帐号出售，还有合租一台VPS服务器的情况。ShadowsocksR，简称SSR，其使用方式同上，增加了混淆的特性，可使翻墙流量伪装成正常流量。ShadowsocksRR，简称SSRR，使用方法同上，与SSR相比增加了更多的混淆方式。Brook，跨平台，基于 GPL v3 协议授权。V2Ray， Project V[11]项目创作的内核，使用自实现的 Vmess 协议及 mKCP 协议，基于 MIT 协议授权。</code></pre><h2 id="VPN"><a href="#VPN" class="headerlink" title="VPN"></a>VPN</h2><p><a href="https://zh.wikipedia.org/wiki/%E8%99%9B%E6%93%AC%E7%A7%81%E4%BA%BA%E7%B6%B2%E8%B7%AF" target="_blank" rel="noopener">虚拟专用网 - 维基百科，自由的百科全书</a></p><pre><code>虚拟私人网络（英语：Virtual Private Network，缩写：VPN）是一种常用于连接中、大型企业或团体与团体间的私人网络的通讯方法。它利用隧道协议（Tunneling Protocol）来达到保密、发送端认证、消息准确性等私人消息安全效果，这种技术可以用不安全的网络（例如：互联网）来发送可靠、安全的消息。</code></pre><p><a href="https://zh.wikipedia.org/wiki/%E9%9A%A7%E9%81%93%E5%8D%8F%E8%AE%AE" target="_blank" rel="noopener">隧道协议 - 维基百科，自由的百科全书</a></p><h3 id="Lantern"><a href="#Lantern" class="headerlink" title="Lantern"></a>Lantern</h3><p><a href="https://github.com/getlantern/download" target="_blank" rel="noopener">蓝灯(Lantern)最新版本下载 Latest version of Lantern 5.3.2</a></p><h3 id="有关VPN的风险性"><a href="#有关VPN的风险性" class="headerlink" title="有关VPN的风险性"></a>有关VPN的风险性</h3><p><a href="http://www.miit.gov.cn/n1146290/n4388791/c5471946/content.html" target="_blank" rel="noopener">工业和信息化部关于清理规范互联网网络接入服务市场的通知 - 中华人民共和国工业和信息化部</a></p><pre><code>2017年1月22日，工业和信息化部发布《工业和信息化部关于清理规范互联网网络接入服务市场的通知》，规定未经电信主管部门（各一级行政区通信管理局）批准，不得自行创建或租用VPN、国际专线等其他信道开展跨境经营活动。而在境内VPN属于《商用密码管理条例》须经国家密码管理局批准。这也意味着在中国大陆的ISP、IDC或CDN提供商租用或创建VPN或国际专线开展业务，必须获取各一级行政区通信管理局的批准。</code></pre><p>但是VPN本来的作用并不是专门干这种事的，有一定的缺陷，比如流量特征可能被GFW分析。<br>2019年发生了第一例个人使用VPN访问境外网站受到行政处罚的事件，所以使用VPN将导致可能被查水表或请喝茶，而且面对GFW不断地升级及某些因素影响，一些特殊时间段可能会使VPN使用体验不佳。</p><p><a href="http://www.gdgafz.alldayfilm.com/bookDetail.html?type=1&amp;id=1134323" target="_blank" rel="noopener">行政处罚决定书[2019]1号 - 广东公安执法信息公开平台</a></p><pre><code>2018年12月28日，广东公安执法信息公开平台公布，韶关南雄公安局发出《韶雄公(网)行罚决字 [2019]1号》文件：朱某某被警方认为“擅自创建、使用非法定信道进行国际联网”而被警告并被罚款1000元。这一行政处罚的依据是1996年颁布的《中华人民共和国计算机信息网络国际联网管理暂行规定》第六条、第十四条。</code></pre><h2 id="SS-SSR"><a href="#SS-SSR" class="headerlink" title="SS | SSR"></a>SS | SSR</h2><p>推荐阅读：<br><a href="https://www.5xiaobo.com/?id=650" target="_blank" rel="noopener">浅谈VPN和SS/SSR的区别</a></p><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>那么先来介绍一下SS与SSR：<br>全称Shadowsocks | ShadowsocksR</p><p>SS的作者Clowwindy因被喝茶而删除其GitHub的源代码，SSR是breakwa11在SS基础上开发的软件，后因某些原因作者在GitHub上将其源代码删除，二软件开发时皆开源并且原作者停止维护后有人开发并维护与更新至今。</p><h3 id="SS"><a href="#SS" class="headerlink" title="SS"></a>SS</h3><p>sock5协议 开源项目 跨平台<br><a href="http://shadowsocks.org/en/index.html" target="_blank" rel="noopener">官网</a></p><p><a href="https://github.com/shadowsocks/shadowsocks-windows/releases" target="_blank" rel="noopener">Github</a></p><h3 id="SSR"><a href="#SSR" class="headerlink" title="SSR"></a>SSR</h3><p>某已经删除的SSR主页（web archive）：<br><a href="https://web.archive.org/web/20170719134138/https://breakwa11.github.io/" target="_blank" rel="noopener">breakwa11.github.io</a></p><p><a href="https://github.com/breakwa11/shadowsocks-csharp/releases" target="_blank" rel="noopener">Github</a></p><p>简单了解一下：<br><a href="https://zh.wikipedia.org/wiki/Shadowsocks" target="_blank" rel="noopener">Shadowsocks - 维基百科，自由的百科全书</a></p><pre><code>Shadowsocks（简称SS）是一种基于Socks5代理方式的加密传输协议，也可以指实现这个协议的各种开发包。当前包使用Python、C、C++、C#、Go语言等编程语言开发，大部分主要实现（iOS平台的除外）采用Apache许可证、GPL、MIT许可证等多种自由软件许可协议开放源代码。Shadowsocks分为服务器端和客户端，在使用之前，需要先将服务器端程序部署到服务器上面，然后通过客户端连接并创建本地代理。</code></pre><p>目前这是比较主流的工具之一，使用人数多，社区比较活跃，但技术上仍并非绝对完美，目前应对GFW足已使用。使用此软件的主要原因是配置方便及社区生态较好。</p><p>在国内社交网站上为避免审查常因其缩写称为酸酸 | 酸酸乳，而因其图标为一个纸飞机，也常称此软件为小飞机、纸飞机等。对提供服务器节点供多人使用的SSR服务提供商称为“机场”。</p><p>SSR分为服务端和客户端，如果你有境外服务器的话，可以直接安装服务端，然后在客户端上使用。当然没有的话你可能需要买个VPS这种东西，当然再然后如果你不需要服务器或没有优质服务器线路及服务器的话，也可以在“机场”获取节点服务器参数来进行使用，一些机场的使用体验比廉价vps更佳。</p><p>界面：<br><img src="/images/ssr1.png" alt></p><p><img src="/images/ssr2.png" alt></p><h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><p>有Windows、Linux、Android、IOS、Macos等系统及各种在源软件基础上开发的很多版本。</p><p>一个仍在维护的Windows版本：</p><p><a href="https://github.com/shadowsocksrr/shadowsocksr-csharp/releases" target="_blank" rel="noopener">https://github.com/shadowsocksrr/shadowsocksr-csharp/releases</a></p><p>一些下载地址及版本介绍：</p><p><a href="https://congcong0806.github.io/2018/04/20/SS/" target="_blank" rel="noopener">SS/SSR 简介</a></p><h3 id="教程"><a href="#教程" class="headerlink" title="教程"></a>教程</h3><h4 id="优先阅读"><a href="#优先阅读" class="headerlink" title="优先阅读"></a>优先阅读</h4><p><a href="https://moe.best/tutorial/shadowsocksr.html" target="_blank" rel="noopener">[ShadowsocksR] 大概是萌新也看得懂的SSR功能详细介绍&amp;使用教程</a></p><p><a href="https://crifan.github.io/scientific_network_summary/website/server_client_mode/ss_client/client_windows.html" target="_blank" rel="noopener">Windows的ss客户端 · 珂学上网相关知识总结</a></p><p>一般的机场都提供教程，也可以谷歌，不再写操作流程了。</p><h3 id="机场"><a href="#机场" class="headerlink" title="机场"></a>机场</h3><p><a href="387099.blogspot.com/2018/03/ssssr.html">浅谈部分机场（SS/SSR提供商）的使用感受</a></p><h3 id="使用技巧"><a href="#使用技巧" class="headerlink" title="使用技巧"></a>使用技巧</h3><p><a href="https://www.i5seo.com/shadowsocksr-clients-various-hidden-use-techniques.html" target="_blank" rel="noopener">ShadowsocksR 客户端 各种隐藏使用技巧说明</a></p><p><a href="https://blog.jimmyho.net/archives/365/" target="_blank" rel="noopener">ShadowsocksR简明使用教程</a></p><h4 id="小飞机的颜色"><a href="#小飞机的颜色" class="headerlink" title="小飞机的颜色"></a>小飞机的颜色</h4><div class="table-container"><table><thead><tr><th style="text-align:center">颜色</th><th style="text-align:center">全局</th><th style="text-align:center">PAC</th><th style="text-align:center">直连</th><th style="text-align:center">负载均衡</th></tr></thead><tbody><tr><td style="text-align:center">白</td><td style="text-align:center">√</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">√</td></tr><tr><td style="text-align:center">青</td><td style="text-align:center">√</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">黄</td><td style="text-align:center"></td><td style="text-align:center">√</td><td style="text-align:center"></td><td style="text-align:center">√</td></tr><tr><td style="text-align:center">绿</td><td style="text-align:center"></td><td style="text-align:center">√</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">紫</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">√</td><td style="text-align:center">√</td></tr><tr><td style="text-align:center">蓝</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">√</td></tr></tbody></table></div><h4 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h4><p>对小飞机托盘图标操作</p><div class="table-container"><table><thead><tr><th style="text-align:center">操作</th><th style="text-align:center">效果</th></tr></thead><tbody><tr><td style="text-align:center">左键单击</td><td style="text-align:center">弹出编辑服务器窗口</td></tr><tr><td style="text-align:center">中键单击</td><td style="text-align:center">弹出服务器连接统计窗</td></tr><tr><td style="text-align:center">右键单击</td><td style="text-align:center">弹出菜单</td></tr></tbody></table></div><h3 id="SSTap"><a href="#SSTap" class="headerlink" title="SSTap"></a>SSTap</h3><p>软件介绍：SSTap全称SOCKSTap, 是一款利用虚拟网卡技术在网络层实现的代理工具。SSTap能在网络层拦截所有连接并转发给HTTP，SOCKS4，5，SHADOWSOCKS代理.而无需对被代理的应用程序做任何修改或设置。它能同时转发TCP,UDP数据包，它非常适合于游戏玩家使用。</p><h3 id="搭建一个ssr服务"><a href="#搭建一个ssr服务" class="headerlink" title="搭建一个ssr服务"></a>搭建一个ssr服务</h3><p>可以谷歌解决，如果日后有时间<del>金钱</del>玩vps的话，会补一个详细的教程。</p><h2 id="V2Ray"><a href="#V2Ray" class="headerlink" title="V2Ray"></a>V2Ray</h2><p>推荐阅读：<br><a href="https://medium.com/@thomas_summon/%E6%B5%85%E8%B0%88vpn-vps-proxy%E4%BB%A5%E5%8F%8Ashadowsocks%E4%B9%8B%E9%97%B4%E7%9A%84%E8%81%94%E7%B3%BB%E5%92%8C%E5%8C%BA%E5%88%AB-b0198f92db1b" target="_blank" rel="noopener">浅谈vpn、vps、Proxy以及shadowsocks之间的联系和区别</a></p><p>比SS | SSR更先进的工具之一，用了更多的技术手段。</p><p>V2Ray 是一个模块化的代理软件包，它的目标是提供常用的代理软件模块，简化网络代理软件的开发。</p><p>简单来说，它就是一个模块化代理，可以用来科学上网，支持多平台。</p><p><a href="https://www.v2ray.com/" target="_blank" rel="noopener">Project V · Project V 官方网站</a></p><p><a href="https://github.com/v2ray/v2ray-core" target="_blank" rel="noopener">Github</a></p><h2 id="Brook"><a href="#Brook" class="headerlink" title="Brook"></a>Brook</h2><p><a href="https://github.com/txthinking/brook" target="_blank" rel="noopener">Github</a></p><h2 id="Tor"><a href="#Tor" class="headerlink" title="Tor"></a>Tor</h2><p><a href="https://www.torproject.org/index.html.en" target="_blank" rel="noopener">官网</a></p><h1 id="一些工具"><a href="#一些工具" class="headerlink" title="一些工具"></a>一些工具</h1><p>一个Chrome的插件</p><pre><code>Yet another flags</code></pre><p>可以很方便的显示服务器IP地址和地理位置。<br>效果：<br><img src="/images/chrome1.png" alt></p><hr><p>一个网站，可以测试网站是否被GFW屏蔽以及文本是否存在被审查的关键字</p><p><a href="https://zh.greatfire.org" target="_blank" rel="noopener">greatfire.org</a></p><h1 id="常用服务"><a href="#常用服务" class="headerlink" title="常用服务"></a>常用服务</h1><p>有GFW</p><h2 id="website"><a href="#website" class="headerlink" title="website"></a>website</h2><p><a href="https://www.google.com.hk" target="_blank" rel="noopener">Google</a></p><p><a href="https://www.youtube.com" target="_blank" rel="noopener">Youtube</a></p><p><a href="https://www.facebook.com" target="_blank" rel="noopener">Facebook</a></p><p><a href="https://twitter.com" target="_blank" rel="noopener">Twitter</a></p><p><a href="https://zh.wikipedia.org" target="_blank" rel="noopener">Wikipedia(zh_CN)</a></p><h2 id="IM"><a href="#IM" class="headerlink" title="IM"></a>IM</h2><p><a href="https://telegram.org" target="_blank" rel="noopener">Telegram</a></p><hr><p>无GFW</p><h2 id="website-1"><a href="#website-1" class="headerlink" title="website"></a>website</h2><p><a href="https://www.quora.com" target="_blank" rel="noopener">Quora</a></p><p><a href="https://github.com" target="_blank" rel="noopener">GitHub</a></p>]]></content>
      
      
      <categories>
          
          <category> PC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GFW </tag>
            
            <tag> SSR </tag>
            
        </tags>
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>gallery</title>
      <link href="/gallery/index.html"/>
      <url>/gallery/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>闲聊</title>
      <link href="/chat/index.html"/>
      <url>/chat/index.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>最后更新：A.D.2019-09-09</p></blockquote><p>纪念生命中的过往烟云</p><h1 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h1><div class="table-container"><table><thead><tr><th>Date</th><th>String</th></tr></thead><tbody><tr><td>2019-6-0x</td><td>搭建了此<code>Blog</code></td></tr><tr><td>2019-9-12</td><td>购买了域名<code>66ccff.xyz</code></td></tr><tr><td>2019-9-22</td><td>用<code>HTML5 up</code>模板制作个人主页并使用域名<code>66ccff.xyz</code>，<code>Blog</code>改为二级域名<code>blog.66ccff.xyz</code></td></tr></tbody></table></div><h1 id="随想"><a href="#随想" class="headerlink" title="随想"></a>随想</h1><div class="table-container"><table><thead><tr><th>Date</th><th>String</th></tr></thead><tbody><tr><td>2019-6-0x</td><td>词语<code>时光 岁月 年华</code></td></tr><tr><td>2019-9-7</td><td>读完了<code>《白鹿原》</code></td></tr><tr><td>2019-9-8</td><td>吃了一颗<code>柠檬</code></td></tr><tr><td>2019-9-10</td><td>开坑<code>套接字</code></td></tr><tr><td>2019-9-14</td><td>看完了刀剑神域<code>Animation</code>的<code>SAO</code>篇</td></tr><tr><td>2019-9-15</td><td>打了第一场<code>Codeforces</code>和<code>AtCoder</code></td></tr></tbody></table></div><h1 id="歌词"><a href="#歌词" class="headerlink" title="歌词"></a>歌词</h1><h2 id="中文Vocaloid"><a href="#中文Vocaloid" class="headerlink" title="中文Vocaloid"></a>中文Vocaloid</h2><div class="table-container"><table><thead><tr><th>Lyrics</th><th>Song</th></tr></thead><tbody><tr><td>每一个梦都是个旋律 漫天回忆该如何去聆听</td><td>Step on your heart -心印-(Album ver) Luna Safari</td></tr><tr><td>晨风中的一缕光 折射梦想的宽广</td><td>Trii - Feel Your Dream 2018</td></tr><tr><td>血色夕阳 温热化作苍凉</td><td>岁月成碑</td></tr><tr><td>破晓夕阳 残月也吝啬藏起光芒 是谁把声音阻挡</td><td>月白色倒影的少女</td></tr><tr><td>如果还能找到你 就让风儿告诉你</td><td>Artificial Emotions</td></tr><tr><td>曾经许下的约定 寻找蔚蓝神秘的行星 不知道 何时才能苏醒 你却留下另一个自己</td><td>Artificial Emotions</td></tr><tr><td>虚和实的叠重，光和影的交错，触摸流云和清风勾勒的美梦</td><td>寻遍星空</td></tr><tr><td>如今的我，徘徊在楼宇的阡陌</td><td>寻遍星空</td></tr><tr><td>夜雾里去闪烁，光年外去诉说，让星辉照耀我浩瀚的宇宙</td><td>寻遍星空</td></tr><tr><td>乘天马遥望北辰飞向云外的月宫</td><td>寻遍星空</td></tr><tr><td>风，将我的思绪打乱，也看不清未来 梦，穿越过人山人海，快要醒来</td><td>化尘旅行</td></tr><tr><td>阳光斜照进窗台，记忆皆化作尘埃</td><td>化尘旅行</td></tr><tr><td>踏着凉鞋 提起裙边 随蝴蝶转啊转 翩飞花前</td><td>夏之歌</td></tr><tr><td>唱，你许下的梦想，在心底里徜徉，就像那梦一样，吹向四面八方</td><td>唱给雅音宫羽Ⅱ</td></tr><tr><td>花落尽时候，又是一个秋</td><td>唱给雅音宫羽Ⅱ</td></tr><tr><td>黑暗里总有光</td><td>春风来</td></tr><tr><td>寻觅着，风的波折</td><td>世末歌者</td></tr><tr><td>用这双手拨出残缺染了锈迹的弦音，都隐没于云雨雾雨幕无声无息</td><td>世末歌者</td></tr><tr><td>或哽咽 或低泣 都融进了泡沫里 拖曳疲惫身躯 沉入冰冷的池底 注视着色彩褪去</td><td>世末歌者</td></tr><tr><td>踏上未知列车 一直飞到云层最高空 紊乱的波形中 猜测前方可能的轮廓 躲藏在月光背后 电讯号变得神秘又莫测</td><td>一日都市</td></tr></tbody></table></div><h2 id="ACGN"><a href="#ACGN" class="headerlink" title="ACGN"></a>ACGN</h2><div class="table-container"><table><thead><tr><th>Lyrics</th><th>Song</th></tr></thead><tbody><tr><td>星月相掩与大海上</td><td>在这个世界相遇</td></tr><tr><td>微风摇曳细雨也彷徨</td><td>在这个世界相遇</td></tr><tr><td>海浪无声将夜幕深深淹没，漫过天空尽头的角落</td><td>大鱼</td></tr><tr><td>看海天一色，听风起雨落，执子手吹散苍茫茫烟波</td><td>大鱼</td></tr><tr><td>日月星辰悄悄，升了又落，我却不知白天黑夜的存在</td><td>湫兮如风</td></tr></tbody></table></div><h1 id="诗词"><a href="#诗词" class="headerlink" title="诗词"></a>诗词</h1><h2 id="日月星辰"><a href="#日月星辰" class="headerlink" title="日月星辰"></a>日月星辰</h2><pre><code>渔家傲    李清照    天接云涛连晓雾，星河欲转千帆舞。仿佛梦魂归帝所。闻天语，殷勤问我归何处。    我报路长嗟日暮，学诗谩有惊人句。九万里风鹏正举。风休住，蓬舟吹取三山去。</code></pre><pre><code>念奴娇·过洞庭    张孝祥            洞庭青草，近中秋，更无一点风色。玉鉴琼田三万顷，着我扁舟一叶。素月分辉，明河共影，表里俱澄澈。悠然心会，妙处难与君说。        应念岭表经年，孤光自照，肝胆皆冰雪。短发萧骚襟袖冷，稳泛沧溟空阔。尽挹西江，细斟北斗，万象为宾客。扣舷独啸，不知今夕何夕。</code></pre><pre><code>七律-送瘟神    毛泽东    绿水青山枉自多，华佗无奈小虫何。千村薜荔人遗矢，万户萧疏鬼唱歌。坐地日行八万里，巡天遥看一千河。牛郎欲问瘟神事，一样悲欢逐逝波。</code></pre><h2 id="自然风景"><a href="#自然风景" class="headerlink" title="自然风景"></a>自然风景</h2><h1 id="人物设定"><a href="#人物设定" class="headerlink" title="人物设定"></a>人物设定</h1><h2 id="Vocaloid"><a href="#Vocaloid" class="headerlink" title="Vocaloid"></a>Vocaloid</h2><div class="table-container"><table><thead><tr><th>Name_1</th><th>Name_2</th><th>Source</th></tr></thead><tbody><tr><td>$\color{rgb(102,204,255)}{洛天依}$</td><td>Luo Tianyi</td><td>Vocaloid-天矢禾念</td></tr><tr><td>$\color{rgb(238,0,0)}{乐正绫}$</td><td>Yuezheng Ling</td><td>Vocaloid-天矢禾念</td></tr><tr><td>$\color{rgb(0,255,204)}{言和}$</td><td>Yan He</td><td>Vocaloid-天矢禾念</td></tr><tr><td>$\color{rgb(153,153,255)}{星尘}\quad$$\color{rgb(255,255,0)}{星尘}$</td><td>Stardust</td><td>Vocaloid-平行四界</td></tr><tr><td>$\color{rgb(238,130,238)}{心华}$</td><td>Xin Hua</td><td>Vocaloid-上海望乘</td></tr><tr><td>$\color{rgb(255,192,203)}{IA}$</td><td>イア</td><td>Vocaloid-1st PLACE</td></tr></tbody></table></div><h2 id="Vtuber"><a href="#Vtuber" class="headerlink" title="Vtuber"></a>Vtuber</h2><div class="table-container"><table><thead><tr><th>Name_1</th><th>Name_2</th><th>Source</th></tr></thead><tbody><tr><td>A.I.Channel</td><td></td><td></td></tr><tr><td>神乐めあ</td><td></td><td></td></tr><tr><td>神乐七奈</td><td></td><td></td></tr><tr><td>白上吹雪</td><td></td><td>hololive一期生</td></tr><tr><td>猫宫日向</td><td></td><td></td></tr><tr><td>时乃空</td><td></td><td></td></tr><tr><td>夏色祭</td><td></td><td>hololive一期生</td></tr><tr><td>新科娘</td><td></td><td>CCTV</td></tr></tbody></table></div><h2 id="ACGN-1"><a href="#ACGN-1" class="headerlink" title="ACGN"></a>ACGN</h2><div class="table-container"><table><thead><tr><th>Name_1</th><th>Name_2</th><th>Source</th><th>ACGN</th></tr></thead><tbody><tr><td>西宫结弦</td><td></td><td>《声之形》</td><td>AC</td></tr><tr><td>西宫硝子</td><td></td><td>《声之形》</td><td>AC</td></tr><tr><td>宫水三叶</td><td></td><td>《你的名字》</td><td>A</td></tr><tr><td>幼刀丛雨</td><td>ムラサメ</td><td>《千恋*万花》</td><td>G</td></tr><tr><td>艾米莉亚</td><td></td><td>《Re:0》</td><td>ACN</td></tr><tr><td>结城明日奈</td><td></td><td>《刀剑神域》</td><td></td></tr><tr><td>桐谷和人</td><td></td><td>《刀剑神域》</td><td></td></tr><tr><td>高板桐乃</td><td></td><td></td><td></td></tr><tr><td>和泉纱雾</td><td></td><td></td></tr></tbody></table></div><h1 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h1><p>感觉我从来没好好看完过一部番的样子……在这里记载一下完整看完的动画作品</p><h2 id="连载"><a href="#连载" class="headerlink" title="连载"></a>连载</h2><div class="table-container"><table><thead><tr><th></th><th></th><th></th></tr></thead><tbody><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td></tr></tbody></table></div><h2 id="电影"><a href="#电影" class="headerlink" title="电影"></a>电影</h2><div class="table-container"><table><thead><tr><th></th><th></th><th></th></tr></thead><tbody><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td></tr></tbody></table></div><h1 id="视频"><a href="#视频" class="headerlink" title="视频"></a>视频</h1><h2 id="Bilibili-Macro-Link-Visual-Release-2019"><a href="#Bilibili-Macro-Link-Visual-Release-2019" class="headerlink" title="Bilibili Macro Link-Visual Release 2019"></a>Bilibili Macro Link-Visual Release 2019</h2><iframe width="560" height="470" src="https://www.youtube.com/embed/yju-0-IOG1g" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>links</title>
      <link href="/links/index.html"/>
      <url>/links/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>tags</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>timeline</title>
      <link href="/timeline/index.html"/>
      <url>/timeline/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>关于</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[<p>咸鱼OIer</p><p>喜欢中v</p><p>喜欢PC游戏</p><p>喜欢一点ACGN</p><p>梦想是当互联网全栈工程师|游戏开发程序员</p><h1 id="技术"><a href="#技术" class="headerlink" title="技术"></a>技术</h1><h2 id="语言"><a href="#语言" class="headerlink" title="语言"></a>语言</h2><p>C/C++ | HTML/CSS/JavaScript | Python</p><h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><p>Markdown | LaTeX | Git</p><h1 id="游戏"><a href="#游戏" class="headerlink" title="游戏"></a>游戏</h1><p>GTA5 侠盗猎车手5</p><p>CS:GO 反恐精英：全球攻势</p><p>Cities:Skylines 城市：天际线</p><p>Planet Coaster 过山车之星</p><p>Minecraft 我的世界</p><h1 id="人文"><a href="#人文" class="headerlink" title="人文"></a>人文</h1><p>诗词</p><p>科幻</p><h1 id="爱好"><a href="#爱好" class="headerlink" title="爱好"></a>爱好</h1><p>中文Vocaloid</p><p>铁路/过山车/城市建设</p><p>画画</p>]]></content>
      
    </entry>
    
    
  
</search>
